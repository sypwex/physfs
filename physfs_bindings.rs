/* automatically generated by rust-bindgen 0.69.4 */

pub const PHYSFS_VER_MAJOR: u32 = 3;
pub const PHYSFS_VER_MINOR: u32 = 0;
pub const PHYSFS_VER_PATCH: u32 = 2;
#[doc = " \\typedef PHYSFS_uint8\n \\brief An unsigned, 8-bit integer type."]
pub type PHYSFS_uint8 = ::std::os::raw::c_uchar;
#[doc = " \\typedef PHYSFS_sint8\n \\brief A signed, 8-bit integer type."]
pub type PHYSFS_sint8 = ::std::os::raw::c_schar;
#[doc = " \\typedef PHYSFS_uint16\n \\brief An unsigned, 16-bit integer type."]
pub type PHYSFS_uint16 = ::std::os::raw::c_ushort;
#[doc = " \\typedef PHYSFS_sint16\n \\brief A signed, 16-bit integer type."]
pub type PHYSFS_sint16 = ::std::os::raw::c_short;
#[doc = " \\typedef PHYSFS_uint32\n \\brief An unsigned, 32-bit integer type."]
pub type PHYSFS_uint32 = ::std::os::raw::c_uint;
#[doc = " \\typedef PHYSFS_sint32\n \\brief A signed, 32-bit integer type."]
pub type PHYSFS_sint32 = ::std::os::raw::c_int;
pub type PHYSFS_uint64 = ::std::os::raw::c_ulonglong;
pub type PHYSFS_sint64 = ::std::os::raw::c_longlong;
pub type PHYSFS_compile_time_assert_uint8IsOneByte = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_sint8IsOneByte = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_uint16IsTwoBytes = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_sint16IsTwoBytes = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_uint32IsFourBytes = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_sint32IsFourBytes = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_uint64IsEightBytes = [::std::os::raw::c_int; 1usize];
pub type PHYSFS_compile_time_assert_sint64IsEightBytes = [::std::os::raw::c_int; 1usize];
#[doc = " \\struct PHYSFS_File\n \\brief A PhysicsFS file handle.\n\n You get a pointer to one of these when you open a file for reading,\n  writing, or appending via PhysicsFS.\n\n As you can see from the lack of meaningful fields, you should treat this\n  as opaque data. Don't try to manipulate the file handle, just pass the\n  pointer you got, unmolested, to various PhysicsFS APIs.\n\n \\sa PHYSFS_openRead\n \\sa PHYSFS_openWrite\n \\sa PHYSFS_openAppend\n \\sa PHYSFS_close\n \\sa PHYSFS_read\n \\sa PHYSFS_write\n \\sa PHYSFS_seek\n \\sa PHYSFS_tell\n \\sa PHYSFS_eof\n \\sa PHYSFS_setBuffer\n \\sa PHYSFS_flush"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_File {
    #[doc = "< That's all you get. Don't touch."]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PHYSFS_File() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_File> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_File>(),
        8usize,
        concat!("Size of: ", stringify!(PHYSFS_File))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_File>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_File))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_File),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " \\struct PHYSFS_ArchiveInfo\n \\brief Information on various PhysicsFS-supported archives.\n\n This structure gives you details on what sort of archives are supported\n  by this implementation of PhysicsFS. Archives tend to be things like\n  ZIP files and such.\n\n \\warning Not all binaries are created equal! PhysicsFS can be built with\n          or without support for various archives. You can check with\n          PHYSFS_supportedArchiveTypes() to see if your archive type is\n          supported.\n\n \\sa PHYSFS_supportedArchiveTypes\n \\sa PHYSFS_registerArchiver\n \\sa PHYSFS_deregisterArchiver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_ArchiveInfo {
    #[doc = "< Archive file extension: \"ZIP\", for example."]
    pub extension: *const ::std::os::raw::c_char,
    #[doc = "< Human-readable archive description."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "< Person who did support for this archive."]
    pub author: *const ::std::os::raw::c_char,
    #[doc = "< URL related to this archive"]
    pub url: *const ::std::os::raw::c_char,
    #[doc = "< non-zero if archive offers symbolic links."]
    pub supportsSymlinks: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PHYSFS_ArchiveInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_ArchiveInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_ArchiveInfo>(),
        40usize,
        concat!("Size of: ", stringify!(PHYSFS_ArchiveInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_ArchiveInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_ArchiveInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_ArchiveInfo),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_ArchiveInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).author) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_ArchiveInfo),
            "::",
            stringify!(author)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_ArchiveInfo),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supportsSymlinks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_ArchiveInfo),
            "::",
            stringify!(supportsSymlinks)
        )
    );
}
#[doc = " \\struct PHYSFS_Version\n \\brief Information the version of PhysicsFS in use.\n\n Represents the library's version as three levels: major revision\n  (increments with massive changes, additions, and enhancements),\n  minor revision (increments with backwards-compatible changes to the\n  major revision), and patchlevel (increments with fixes to the minor\n  revision).\n\n \\sa PHYSFS_VERSION\n \\sa PHYSFS_getLinkedVersion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_Version {
    #[doc = "< major revision"]
    pub major: PHYSFS_uint8,
    #[doc = "< minor revision"]
    pub minor: PHYSFS_uint8,
    #[doc = "< patchlevel"]
    pub patch: PHYSFS_uint8,
}
#[test]
fn bindgen_test_layout_PHYSFS_Version() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_Version> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_Version>(),
        3usize,
        concat!("Size of: ", stringify!(PHYSFS_Version))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_Version>(),
        1usize,
        concat!("Alignment of ", stringify!(PHYSFS_Version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = " \\fn void PHYSFS_getLinkedVersion(PHYSFS_Version *ver)\n \\brief Get the version of PhysicsFS that is linked against your program.\n\n If you are using a shared library (DLL) version of PhysFS, then it is\n  possible that it will be different than the version you compiled against.\n\n This is a real function; the macro PHYSFS_VERSION tells you what version\n  of PhysFS you compiled against:\n\n \\code\n PHYSFS_Version compiled;\n PHYSFS_Version linked;\n\n PHYSFS_VERSION(&compiled);\n PHYSFS_getLinkedVersion(&linked);\n printf(\"We compiled against PhysFS version %d.%d.%d ...\\n\",\n           compiled.major, compiled.minor, compiled.patch);\n printf(\"But we linked against PhysFS version %d.%d.%d.\\n\",\n           linked.major, linked.minor, linked.patch);\n \\endcode\n\n This function may be called safely at any time, even before PHYSFS_init().\n\n \\sa PHYSFS_VERSION"]
    pub fn PHYSFS_getLinkedVersion(ver: *mut PHYSFS_Version);
}
extern "C" {
    #[doc = " \\fn int PHYSFS_init(const char *argv0)\n \\brief Initialize the PhysicsFS library.\n\n This must be called before any other PhysicsFS function.\n\n This should be called prior to any attempts to change your process's\n  current working directory.\n\n   \\param argv0 the argv[0] string passed to your program's mainline.\n          This may be NULL on most platforms (such as ones without a\n          standard main() function), but you should always try to pass\n          something in here. Unix-like systems such as Linux _need_ to\n          pass argv[0] from main() in here.\n  \\return nonzero on success, zero on error. Specifics of the error can be\n          gleaned from PHYSFS_getLastError().\n\n \\sa PHYSFS_deinit\n \\sa PHYSFS_isInit"]
    pub fn PHYSFS_init(argv0: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_deinit(void)\n \\brief Deinitialize the PhysicsFS library.\n\n This closes any files opened via PhysicsFS, blanks the search/write paths,\n  frees memory, and invalidates all of your file handles.\n\n Note that this call can FAIL if there's a file open for writing that\n  refuses to close (for example, the underlying operating system was\n  buffering writes to network filesystem, and the fileserver has crashed,\n  or a hard drive has failed, etc). It is usually best to close all write\n  handles yourself before calling this function, so that you can gracefully\n  handle a specific failure.\n\n Once successfully deinitialized, PHYSFS_init() can be called again to\n  restart the subsystem. All default API states are restored at this\n  point, with the exception of any custom allocator you might have\n  specified, which survives between initializations.\n\n  \\return nonzero on success, zero on error. Specifics of the error can be\n          gleaned from PHYSFS_getLastError(). If failure, state of PhysFS is\n          undefined, and probably badly screwed up.\n\n \\sa PHYSFS_init\n \\sa PHYSFS_isInit"]
    pub fn PHYSFS_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn const PHYSFS_ArchiveInfo **PHYSFS_supportedArchiveTypes(void)\n \\brief Get a list of supported archive types.\n\n Get a list of archive types supported by this implementation of PhysicFS.\n  These are the file formats usable for search path entries. This is for\n  informational purposes only. Note that the extension listed is merely\n  convention: if we list \"ZIP\", you can open a PkZip-compatible archive\n  with an extension of \"XYZ\", if you like.\n\n The returned value is an array of pointers to PHYSFS_ArchiveInfo structures,\n  with a NULL entry to signify the end of the list:\n\n \\code\n PHYSFS_ArchiveInfo **i;\n\n for (i = PHYSFS_supportedArchiveTypes(); *i != NULL; i++)\n {\n     printf(\"Supported archive: [%s], which is [%s].\\n\",\n              (*i)->extension, (*i)->description);\n }\n \\endcode\n\n The return values are pointers to internal memory, and should\n  be considered READ ONLY, and never freed. The returned values are\n  valid until the next call to PHYSFS_deinit(), PHYSFS_registerArchiver(),\n  or PHYSFS_deregisterArchiver().\n\n   \\return READ ONLY Null-terminated array of READ ONLY structures.\n\n \\sa PHYSFS_registerArchiver\n \\sa PHYSFS_deregisterArchiver"]
    pub fn PHYSFS_supportedArchiveTypes() -> *mut *const PHYSFS_ArchiveInfo;
}
extern "C" {
    #[doc = " \\fn void PHYSFS_freeList(void *listVar)\n \\brief Deallocate resources of lists returned by PhysicsFS.\n\n Certain PhysicsFS functions return lists of information that are\n  dynamically allocated. Use this function to free those resources.\n\n It is safe to pass a NULL here, but doing so will cause a crash in versions\n  before PhysicsFS 2.1.0.\n\n   \\param listVar List of information specified as freeable by this function.\n                  Passing NULL is safe; it is a valid no-op.\n\n \\sa PHYSFS_getCdRomDirs\n \\sa PHYSFS_enumerateFiles\n \\sa PHYSFS_getSearchPath"]
    pub fn PHYSFS_freeList(listVar: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getLastError(void)\n \\brief Get human-readable error information.\n\n \\deprecated Use PHYSFS_getLastErrorCode() and PHYSFS_getErrorByCode() instead.\n\n \\warning As of PhysicsFS 2.1, this function has been nerfed.\n          Before PhysicsFS 2.1, this function was the only way to get\n          error details beyond a given function's basic return value.\n          This was meant to be a human-readable string in one of several\n          languages, and was not useful for application parsing. This was\n          a problem, because the developer and not the user chose the\n          language at compile time, and the PhysicsFS maintainers had\n          to (poorly) maintain a significant amount of localization work.\n          The app couldn't parse the strings, even if they counted on a\n          specific language, since some were dynamically generated.\n          In 2.1 and later, this always returns a static string in\n          English; you may use it as a key string for your own\n          localizations if you like, as we'll promise not to change\n          existing error strings. Also, if your application wants to\n          look at specific errors, we now offer a better option:\n          use PHYSFS_getLastErrorCode() instead.\n\n Get the last PhysicsFS error message as a human-readable, null-terminated\n  string. This will return NULL if there's been no error since the last call\n  to this function. The pointer returned by this call points to an internal\n  buffer. Each thread has a unique error state associated with it, but each\n  time a new error message is set, it will overwrite the previous one\n  associated with that thread. It is safe to call this function at anytime,\n  even before PHYSFS_init().\n\n PHYSFS_getLastError() and PHYSFS_getLastErrorCode() both reset the same\n  thread-specific error state. Calling one will wipe out the other's\n  data. If you need both, call PHYSFS_getLastErrorCode(), then pass that\n  value to PHYSFS_getErrorByCode().\n\n As of PhysicsFS 2.1, this function only presents text in the English\n  language, but the strings are static, so you can use them as keys into\n  your own localization dictionary. These strings are meant to be passed on\n  directly to the user.\n\n Generally, applications should only concern themselves with whether a\n  given function failed; however, if your code require more specifics, you\n  should use PHYSFS_getLastErrorCode() instead of this function.\n\n   \\return READ ONLY string of last error message.\n\n \\sa PHYSFS_getLastErrorCode\n \\sa PHYSFS_getErrorByCode"]
    pub fn PHYSFS_getLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getDirSeparator(void)\n \\brief Get platform-dependent dir separator string.\n\n This returns \"\\\\\" on win32, \"/\" on Unix, and \":\" on MacOS. It may be more\n  than one character, depending on the platform, and your code should take\n  that into account. Note that this is only useful for setting up the\n  search/write paths, since access into those dirs always use '/'\n  (platform-independent notation) to separate directories. This is also\n  handy for getting platform-independent access when using stdio calls.\n\n   \\return READ ONLY null-terminated string of platform's dir separator."]
    pub fn PHYSFS_getDirSeparator() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn void PHYSFS_permitSymbolicLinks(int allow)\n \\brief Enable or disable following of symbolic links.\n\n Some physical filesystems and archives contain files that are just pointers\n  to other files. On the physical filesystem, opening such a link will\n  (transparently) open the file that is pointed to.\n\n By default, PhysicsFS will check if a file is really a symlink during open\n  calls and fail if it is. Otherwise, the link could take you outside the\n  write and search paths, and compromise security.\n\n If you want to take that risk, call this function with a non-zero parameter.\n  Note that this is more for sandboxing a program's scripting language, in\n  case untrusted scripts try to compromise the system. Generally speaking,\n  a user could very well have a legitimate reason to set up a symlink, so\n  unless you feel there's a specific danger in allowing them, you should\n  permit them.\n\n Symlinks are only explicitly checked when dealing with filenames\n  in platform-independent notation. That is, when setting up your\n  search and write paths, etc, symlinks are never checked for.\n\n Please note that PHYSFS_stat() will always check the path specified; if\n  that path is a symlink, it will not be followed in any case. If symlinks\n  aren't permitted through this function, PHYSFS_stat() ignores them, and\n  would treat the query as if the path didn't exist at all.\n\n Symbolic link permission can be enabled or disabled at any time after\n  you've called PHYSFS_init(), and is disabled by default.\n\n   \\param allow nonzero to permit symlinks, zero to deny linking.\n\n \\sa PHYSFS_symbolicLinksPermitted"]
    pub fn PHYSFS_permitSymbolicLinks(allow: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\fn char **PHYSFS_getCdRomDirs(void)\n \\brief Get an array of paths to available CD-ROM drives.\n\n The dirs returned are platform-dependent (\"D:\\\" on Win32, \"/cdrom\" or\n  whatnot on Unix). Dirs are only returned if there is a disc ready and\n  accessible in the drive. So if you've got two drives (D: and E:), and only\n  E: has a disc in it, then that's all you get. If the user inserts a disc\n  in D: and you call this function again, you get both drives. If, on a\n  Unix box, the user unmounts a disc and remounts it elsewhere, the next\n  call to this function will reflect that change.\n\n This function refers to \"CD-ROM\" media, but it really means \"inserted disc\n  media,\" such as DVD-ROM, HD-DVD, CDRW, and Blu-Ray discs. It looks for\n  filesystems, and as such won't report an audio CD, unless there's a\n  mounted filesystem track on it.\n\n The returned value is an array of strings, with a NULL entry to signify the\n  end of the list:\n\n \\code\n char **cds = PHYSFS_getCdRomDirs();\n char **i;\n\n for (i = cds; *i != NULL; i++)\n     printf(\"cdrom dir [%s] is available.\\n\", *i);\n\n PHYSFS_freeList(cds);\n \\endcode\n\n This call may block while drives spin up. Be forewarned.\n\n When you are done with the returned information, you may dispose of the\n  resources by calling PHYSFS_freeList() with the returned pointer.\n\n   \\return Null-terminated array of null-terminated strings.\n\n \\sa PHYSFS_getCdRomDirsCallback"]
    pub fn PHYSFS_getCdRomDirs() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getBaseDir(void)\n \\brief Get the path where the application resides.\n\n Helper function.\n\n Get the \"base dir\". This is the directory where the application was run\n  from, which is probably the installation directory, and may or may not\n  be the process's current working directory.\n\n You should probably use the base dir in your search path.\n\n  \\return READ ONLY string of base dir in platform-dependent notation.\n\n \\sa PHYSFS_getPrefDir"]
    pub fn PHYSFS_getBaseDir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getUserDir(void)\n \\brief Get the path where user's home directory resides.\n\n \\deprecated As of PhysicsFS 2.1, you probably want PHYSFS_getPrefDir().\n\n Helper function.\n\n Get the \"user dir\". This is meant to be a suggestion of where a specific\n  user of the system can store files. On Unix, this is her home directory.\n  On systems with no concept of multiple home directories (MacOS, win95),\n  this will default to something like \"C:\\mybasedir\\users\\username\"\n  where \"username\" will either be the login name, or \"default\" if the\n  platform doesn't support multiple users, either.\n\n  \\return READ ONLY string of user dir in platform-dependent notation.\n\n \\sa PHYSFS_getBaseDir\n \\sa PHYSFS_getPrefDir"]
    pub fn PHYSFS_getUserDir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getWriteDir(void)\n \\brief Get path where PhysicsFS will allow file writing.\n\n Get the current write dir. The default write dir is NULL.\n\n  \\return READ ONLY string of write dir in platform-dependent notation,\n           OR NULL IF NO WRITE PATH IS CURRENTLY SET.\n\n \\sa PHYSFS_setWriteDir"]
    pub fn PHYSFS_getWriteDir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_setWriteDir(const char *newDir)\n \\brief Tell PhysicsFS where it may write files.\n\n Set a new write dir. This will override the previous setting.\n\n This call will fail (and fail to change the write dir) if the current\n  write dir still has files open in it.\n\n   \\param newDir The new directory to be the root of the write dir,\n                   specified in platform-dependent notation. Setting to NULL\n                   disables the write dir, so no files can be opened for\n                   writing via PhysicsFS.\n  \\return non-zero on success, zero on failure. All attempts to open a file\n           for writing via PhysicsFS will fail until this call succeeds.\n           Use PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_getWriteDir"]
    pub fn PHYSFS_setWriteDir(newDir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_addToSearchPath(const char *newDir, int appendToPath)\n \\brief Add an archive or directory to the search path.\n\n \\deprecated As of PhysicsFS 2.0, use PHYSFS_mount() instead. This\n             function just wraps it anyhow.\n\n This function is equivalent to:\n\n \\code\n  PHYSFS_mount(newDir, NULL, appendToPath);\n \\endcode\n\n You must use this and not PHYSFS_mount if binary compatibility with\n  PhysicsFS 1.0 is important (which it may not be for many people).\n\n \\sa PHYSFS_mount\n \\sa PHYSFS_removeFromSearchPath\n \\sa PHYSFS_getSearchPath"]
    pub fn PHYSFS_addToSearchPath(
        newDir: *const ::std::os::raw::c_char,
        appendToPath: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_removeFromSearchPath(const char *oldDir)\n \\brief Remove a directory or archive from the search path.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_unmount() instead. This\n             function just wraps it anyhow. There's no functional difference\n             except the vocabulary changed from \"adding to the search path\"\n             to \"mounting\" when that functionality was extended, and thus\n             the preferred way to accomplish this function's work is now\n             called \"unmounting.\"\n\n This function is equivalent to:\n\n \\code\n  PHYSFS_unmount(oldDir);\n \\endcode\n\n You must use this and not PHYSFS_unmount if binary compatibility with\n  PhysicsFS 1.0 is important (which it may not be for many people).\n\n \\sa PHYSFS_addToSearchPath\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_unmount"]
    pub fn PHYSFS_removeFromSearchPath(
        oldDir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn char **PHYSFS_getSearchPath(void)\n \\brief Get the current search path.\n\n The default search path is an empty list.\n\n The returned value is an array of strings, with a NULL entry to signify the\n  end of the list:\n\n \\code\n char **i;\n\n for (i = PHYSFS_getSearchPath(); *i != NULL; i++)\n     printf(\"[%s] is in the search path.\\n\", *i);\n \\endcode\n\n When you are done with the returned information, you may dispose of the\n  resources by calling PHYSFS_freeList() with the returned pointer.\n\n   \\return Null-terminated array of null-terminated strings. NULL if there\n            was a problem (read: OUT OF MEMORY).\n\n \\sa PHYSFS_getSearchPathCallback\n \\sa PHYSFS_addToSearchPath\n \\sa PHYSFS_removeFromSearchPath"]
    pub fn PHYSFS_getSearchPath() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_setSaneConfig(const char *organization, const char *appName, const char *archiveExt, int includeCdRoms, int archivesFirst)\n \\brief Set up sane, default paths.\n\n Helper function.\n\n The write dir will be set to the pref dir returned by\n  \\code PHYSFS_getPrefDir(organization, appName) \\endcode, which is\n  created if it doesn't exist.\n\n The above is sufficient to make sure your program's configuration directory\n  is separated from other clutter, and platform-independent.\n\n  The search path will be:\n\n    - The Write Dir (created if it doesn't exist)\n    - The Base Dir (PHYSFS_getBaseDir())\n    - All found CD-ROM dirs (optionally)\n\n These directories are then searched for files ending with the extension\n  (archiveExt), which, if they are valid and supported archives, will also\n  be added to the search path. If you specified \"PKG\" for (archiveExt), and\n  there's a file named data.PKG in the base dir, it'll be checked. Archives\n  can either be appended or prepended to the search path in alphabetical\n  order, regardless of which directories they were found in. All archives\n  are mounted in the root of the virtual file system (\"/\").\n\n All of this can be accomplished from the application, but this just does it\n  all for you. Feel free to add more to the search path manually, too.\n\n    \\param organization Name of your company/group/etc to be used as a\n                         dirname, so keep it small, and no-frills.\n\n    \\param appName Program-specific name of your program, to separate it\n                   from other programs using PhysicsFS.\n\n    \\param archiveExt File extension used by your program to specify an\n                      archive. For example, Quake 3 uses \"pk3\", even though\n                      they are just zipfiles. Specify NULL to not dig out\n                      archives automatically. Do not specify the '.' char;\n                      If you want to look for ZIP files, specify \"ZIP\" and\n                      not \".ZIP\" ... the archive search is case-insensitive.\n\n    \\param includeCdRoms Non-zero to include CD-ROMs in the search path, and\n                         (if (archiveExt) != NULL) search them for archives.\n                         This may cause a significant amount of blocking\n                         while discs are accessed, and if there are no discs\n                         in the drive (or even not mounted on Unix systems),\n                         then they may not be made available anyhow. You may\n                         want to specify zero and handle the disc setup\n                         yourself.\n\n    \\param archivesFirst Non-zero to prepend the archives to the search path.\n                         Zero to append them. Ignored if !(archiveExt).\n\n  \\return nonzero on success, zero on error. Use PHYSFS_getLastErrorCode()\n          to obtain the specific error."]
    pub fn PHYSFS_setSaneConfig(
        organization: *const ::std::os::raw::c_char,
        appName: *const ::std::os::raw::c_char,
        archiveExt: *const ::std::os::raw::c_char,
        includeCdRoms: ::std::os::raw::c_int,
        archivesFirst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_mkdir(const char *dirName)\n \\brief Create a directory.\n\n This is specified in platform-independent notation in relation to the\n  write dir. All missing parent directories are also created if they\n  don't exist.\n\n So if you've got the write dir set to \"C:\\mygame\\writedir\" and call\n  PHYSFS_mkdir(\"downloads/maps\") then the directories\n  \"C:\\mygame\\writedir\\downloads\" and \"C:\\mygame\\writedir\\downloads\\maps\"\n  will be created if possible. If the creation of \"maps\" fails after we\n  have successfully created \"downloads\", then the function leaves the\n  created directory behind and reports failure.\n\n   \\param dirName New dir to create.\n  \\return nonzero on success, zero on error. Use\n          PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_delete"]
    pub fn PHYSFS_mkdir(dirName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_delete(const char *filename)\n \\brief Delete a file or directory.\n\n (filename) is specified in platform-independent notation in relation to the\n  write dir.\n\n A directory must be empty before this call can delete it.\n\n Deleting a symlink will remove the link, not what it points to, regardless\n  of whether you \"permitSymLinks\" or not.\n\n So if you've got the write dir set to \"C:\\mygame\\writedir\" and call\n  PHYSFS_delete(\"downloads/maps/level1.map\") then the file\n  \"C:\\mygame\\writedir\\downloads\\maps\\level1.map\" is removed from the\n  physical filesystem, if it exists and the operating system permits the\n  deletion.\n\n Note that on Unix systems, deleting a file may be successful, but the\n  actual file won't be removed until all processes that have an open\n  filehandle to it (including your program) close their handles.\n\n Chances are, the bits that make up the file still exist, they are just\n  made available to be written over at a later point. Don't consider this\n  a security method or anything.  :)\n\n   \\param filename Filename to delete.\n  \\return nonzero on success, zero on error. Use PHYSFS_getLastErrorCode()\n          to obtain the specific error."]
    pub fn PHYSFS_delete(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getRealDir(const char *filename)\n \\brief Figure out where in the search path a file resides.\n\n The file is specified in platform-independent notation. The returned\n  filename will be the element of the search path where the file was found,\n  which may be a directory, or an archive. Even if there are multiple\n  matches in different parts of the search path, only the first one found\n  is used, just like when opening a file.\n\n So, if you look for \"maps/level1.map\", and C:\\\\mygame is in your search\n  path and C:\\\\mygame\\\\maps\\\\level1.map exists, then \"C:\\mygame\" is returned.\n\n If a any part of a match is a symbolic link, and you've not explicitly\n  permitted symlinks, then it will be ignored, and the search for a match\n  will continue.\n\n If you specify a fake directory that only exists as a mount point, it'll\n  be associated with the first archive mounted there, even though that\n  directory isn't necessarily contained in a real archive.\n\n \\warning This will return NULL if there is no real directory associated\n          with (filename). Specifically, PHYSFS_mountIo(),\n          PHYSFS_mountMemory(), and PHYSFS_mountHandle() will return NULL\n          even if the filename is found in the search path. Plan accordingly.\n\n     \\param filename file to look for.\n    \\return READ ONLY string of element of search path containing the\n             the file in question. NULL if not found."]
    pub fn PHYSFS_getRealDir(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn char **PHYSFS_enumerateFiles(const char *dir)\n \\brief Get a file listing of a search path's directory.\n\n \\warning In PhysicsFS versions prior to 2.1, this function would return\n          as many items as it could in the face of a failure condition\n          (out of memory, disk i/o error, etc). Since this meant apps\n          couldn't distinguish between complete success and partial failure,\n          and since the function could always return NULL to report\n          catastrophic failures anyway, in PhysicsFS 2.1 this function's\n          policy changed: it will either return a list of complete results\n          or it will return NULL for any failure of any kind, so we can\n          guarantee that the enumeration ran to completion and has no gaps\n          in its results.\n\n Matching directories are interpolated. That is, if \"C:\\mydir\" is in the\n  search path and contains a directory \"savegames\" that contains \"x.sav\",\n  \"y.sav\", and \"z.sav\", and there is also a \"C:\\userdir\" in the search path\n  that has a \"savegames\" subdirectory with \"w.sav\", then the following code:\n\n \\code\n char **rc = PHYSFS_enumerateFiles(\"savegames\");\n char **i;\n\n for (i = rc; *i != NULL; i++)\n     printf(\" * We've got [%s].\\n\", *i);\n\n PHYSFS_freeList(rc);\n \\endcode\n\n  \\...will print:\n\n \\verbatim\n We've got [x.sav].\n We've got [y.sav].\n We've got [z.sav].\n We've got [w.sav].\\endverbatim\n\n Feel free to sort the list however you like. However, the returned data\n  will always contain no duplicates, and will be always sorted in alphabetic\n  (rather: case-sensitive Unicode) order for you.\n\n Don't forget to call PHYSFS_freeList() with the return value from this\n  function when you are done with it.\n\n    \\param dir directory in platform-independent notation to enumerate.\n   \\return Null-terminated array of null-terminated strings, or NULL for\n           failure cases.\n\n \\sa PHYSFS_enumerate"]
    pub fn PHYSFS_enumerateFiles(
        dir: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_exists(const char *fname)\n \\brief Determine if a file exists in the search path.\n\n Reports true if there is an entry anywhere in the search path by the\n  name of (fname).\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, so you\n  might end up further down in the search path than expected.\n\n    \\param fname filename in platform-independent notation.\n   \\return non-zero if filename exists. zero otherwise."]
    pub fn PHYSFS_exists(fname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_isDirectory(const char *fname)\n \\brief Determine if a file in the search path is really a directory.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_stat() instead. This\n             function just wraps it anyhow.\n\n Determine if the first occurence of (fname) in the search path is\n  really a directory entry.\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, so you\n  might end up further down in the search path than expected.\n\n    \\param fname filename in platform-independent notation.\n   \\return non-zero if filename exists and is a directory.  zero otherwise.\n\n \\sa PHYSFS_stat\n \\sa PHYSFS_exists"]
    pub fn PHYSFS_isDirectory(fname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_isSymbolicLink(const char *fname)\n \\brief Determine if a file in the search path is really a symbolic link.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_stat() instead. This\n             function just wraps it anyhow.\n\n Determine if the first occurence of (fname) in the search path is\n  really a symbolic link.\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, and as such,\n  this function will always return 0 in that case.\n\n    \\param fname filename in platform-independent notation.\n   \\return non-zero if filename exists and is a symlink.  zero otherwise.\n\n \\sa PHYSFS_stat\n \\sa PHYSFS_exists"]
    pub fn PHYSFS_isSymbolicLink(fname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_getLastModTime(const char *filename)\n \\brief Get the last modification time of a file.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_stat() instead. This\n             function just wraps it anyhow.\n\n The modtime is returned as a number of seconds since the Unix epoch\n  (midnight, Jan 1, 1970). The exact derivation and accuracy of this time\n  depends on the particular archiver. If there is no reasonable way to\n  obtain this information for a particular archiver, or there was some sort\n  of error, this function returns (-1).\n\n You must use this and not PHYSFS_stat() if binary compatibility with\n  PhysicsFS 2.0 is important (which it may not be for many people).\n\n   \\param filename filename to check, in platform-independent notation.\n  \\return last modified time of the file. -1 if it can't be determined.\n\n \\sa PHYSFS_stat"]
    pub fn PHYSFS_getLastModTime(filename: *const ::std::os::raw::c_char) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_File *PHYSFS_openWrite(const char *filename)\n \\brief Open a file for writing.\n\n Open a file for writing, in platform-independent notation and in relation\n  to the write dir as the root of the writable filesystem. The specified\n  file is created if it doesn't exist. If it does exist, it is truncated to\n  zero bytes, and the writing offset is set to the start.\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a\n  symlink with this function will fail in such a case.\n\n   \\param filename File to open.\n  \\return A valid PhysicsFS filehandle on success, NULL on error. Use\n          PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_openRead\n \\sa PHYSFS_openAppend\n \\sa PHYSFS_write\n \\sa PHYSFS_close"]
    pub fn PHYSFS_openWrite(filename: *const ::std::os::raw::c_char) -> *mut PHYSFS_File;
}
extern "C" {
    #[doc = " \\fn PHYSFS_File *PHYSFS_openAppend(const char *filename)\n \\brief Open a file for appending.\n\n Open a file for writing, in platform-independent notation and in relation\n  to the write dir as the root of the writable filesystem. The specified\n  file is created if it doesn't exist. If it does exist, the writing offset\n  is set to the end of the file, so the first write will be the byte after\n  the end.\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a\n  symlink with this function will fail in such a case.\n\n   \\param filename File to open.\n  \\return A valid PhysicsFS filehandle on success, NULL on error. Use\n          PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_openRead\n \\sa PHYSFS_openWrite\n \\sa PHYSFS_write\n \\sa PHYSFS_close"]
    pub fn PHYSFS_openAppend(filename: *const ::std::os::raw::c_char) -> *mut PHYSFS_File;
}
extern "C" {
    #[doc = " \\fn PHYSFS_File *PHYSFS_openRead(const char *filename)\n \\brief Open a file for reading.\n\n Open a file for reading, in platform-independent notation. The search path\n  is checked one at a time until a matching file is found, in which case an\n  abstract filehandle is associated with it, and reading may be done.\n  The reading offset is set to the first byte of the file.\n\n Note that entries that are symlinks are ignored if\n  PHYSFS_permitSymbolicLinks(1) hasn't been called, and opening a\n  symlink with this function will fail in such a case.\n\n   \\param filename File to open.\n  \\return A valid PhysicsFS filehandle on success, NULL on error.\n          Use PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_openWrite\n \\sa PHYSFS_openAppend\n \\sa PHYSFS_read\n \\sa PHYSFS_close"]
    pub fn PHYSFS_openRead(filename: *const ::std::os::raw::c_char) -> *mut PHYSFS_File;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_close(PHYSFS_File *handle)\n \\brief Close a PhysicsFS filehandle.\n\n This call is capable of failing if the operating system was buffering\n  writes to the physical media, and, now forced to write those changes to\n  physical media, can not store the data for some reason. In such a case,\n  the filehandle stays open. A well-written program should ALWAYS check the\n  return value from the close call in addition to every writing call!\n\n   \\param handle handle returned from PHYSFS_open*().\n  \\return nonzero on success, zero on error. Use PHYSFS_getLastErrorCode()\n          to obtain the specific error.\n\n \\sa PHYSFS_openRead\n \\sa PHYSFS_openWrite\n \\sa PHYSFS_openAppend"]
    pub fn PHYSFS_close(handle: *mut PHYSFS_File) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_read(PHYSFS_File *handle, void *buffer, PHYSFS_uint32 objSize, PHYSFS_uint32 objCount)\n \\brief Read data from a PhysicsFS filehandle\n\n The file must be opened for reading.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_readBytes() instead. This\n             function just wraps it anyhow. This function never clarified\n             what would happen if you managed to read a partial object, so\n             working at the byte level makes this cleaner for everyone,\n             especially now that PHYSFS_Io interfaces can be supplied by the\n             application.\n\n   \\param handle handle returned from PHYSFS_openRead().\n   \\param buffer buffer to store read data into.\n   \\param objSize size in bytes of objects being read from (handle).\n   \\param objCount number of (objSize) objects to read from (handle).\n  \\return number of objects read. PHYSFS_getLastErrorCode() can shed light\n          on the reason this might be < (objCount), as can PHYSFS_eof().\n          -1 if complete failure.\n\n \\sa PHYSFS_readBytes\n \\sa PHYSFS_eof"]
    pub fn PHYSFS_read(
        handle: *mut PHYSFS_File,
        buffer: *mut ::std::os::raw::c_void,
        objSize: PHYSFS_uint32,
        objCount: PHYSFS_uint32,
    ) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_write(PHYSFS_File *handle, const void *buffer, PHYSFS_uint32 objSize, PHYSFS_uint32 objCount)\n \\brief Write data to a PhysicsFS filehandle\n\n The file must be opened for writing.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_writeBytes() instead. This\n             function just wraps it anyhow. This function never clarified\n             what would happen if you managed to write a partial object, so\n             working at the byte level makes this cleaner for everyone,\n             especially now that PHYSFS_Io interfaces can be supplied by the\n             application.\n\n   \\param handle retval from PHYSFS_openWrite() or PHYSFS_openAppend().\n   \\param buffer buffer of bytes to write to (handle).\n   \\param objSize size in bytes of objects being written to (handle).\n   \\param objCount number of (objSize) objects to write to (handle).\n  \\return number of objects written. PHYSFS_getLastErrorCode() can shed\n          light on the reason this might be < (objCount). -1 if complete\n          failure.\n\n \\sa PHYSFS_writeBytes"]
    pub fn PHYSFS_write(
        handle: *mut PHYSFS_File,
        buffer: *const ::std::os::raw::c_void,
        objSize: PHYSFS_uint32,
        objCount: PHYSFS_uint32,
    ) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_eof(PHYSFS_File *handle)\n \\brief Check for end-of-file state on a PhysicsFS filehandle.\n\n Determine if the end of file has been reached in a PhysicsFS filehandle.\n\n   \\param handle handle returned from PHYSFS_openRead().\n  \\return nonzero if EOF, zero if not.\n\n \\sa PHYSFS_read\n \\sa PHYSFS_tell"]
    pub fn PHYSFS_eof(handle: *mut PHYSFS_File) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_tell(PHYSFS_File *handle)\n \\brief Determine current position within a PhysicsFS filehandle.\n\n   \\param handle handle returned from PHYSFS_open*().\n  \\return offset in bytes from start of file. -1 if error occurred.\n           Use PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_seek"]
    pub fn PHYSFS_tell(handle: *mut PHYSFS_File) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_seek(PHYSFS_File *handle, PHYSFS_uint64 pos)\n \\brief Seek to a new position within a PhysicsFS filehandle.\n\n The next read or write will occur at that place. Seeking past the\n  beginning or end of the file is not allowed, and causes an error.\n\n   \\param handle handle returned from PHYSFS_open*().\n   \\param pos number of bytes from start of file to seek to.\n  \\return nonzero on success, zero on error. Use PHYSFS_getLastErrorCode()\n          to obtain the specific error.\n\n \\sa PHYSFS_tell"]
    pub fn PHYSFS_seek(handle: *mut PHYSFS_File, pos: PHYSFS_uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_fileLength(PHYSFS_File *handle)\n \\brief Get total length of a file in bytes.\n\n Note that if another process/thread is writing to this file at the same\n  time, then the information this function supplies could be incorrect\n  before you get it. Use with caution, or better yet, don't use at all.\n\n   \\param handle handle returned from PHYSFS_open*().\n  \\return size in bytes of the file. -1 if can't be determined.\n\n \\sa PHYSFS_tell\n \\sa PHYSFS_seek"]
    pub fn PHYSFS_fileLength(handle: *mut PHYSFS_File) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_setBuffer(PHYSFS_File *handle, PHYSFS_uint64 bufsize)\n \\brief Set up buffering for a PhysicsFS file handle.\n\n Define an i/o buffer for a file handle. A memory block of (bufsize) bytes\n  will be allocated and associated with (handle).\n\n For files opened for reading, up to (bufsize) bytes are read from (handle)\n  and stored in the internal buffer. Calls to PHYSFS_read() will pull\n  from this buffer until it is empty, and then refill it for more reading.\n  Note that compressed files, like ZIP archives, will decompress while\n  buffering, so this can be handy for offsetting CPU-intensive operations.\n  The buffer isn't filled until you do your next read.\n\n For files opened for writing, data will be buffered to memory until the\n  buffer is full or the buffer is flushed. Closing a handle implicitly\n  causes a flush...check your return values!\n\n Seeking, etc transparently accounts for buffering.\n\n You can resize an existing buffer by calling this function more than once\n  on the same file. Setting the buffer size to zero will free an existing\n  buffer.\n\n PhysicsFS file handles are unbuffered by default.\n\n Please check the return value of this function! Failures can include\n  not being able to seek backwards in a read-only file when removing the\n  buffer, not being able to allocate the buffer, and not being able to\n  flush the buffer to disk, among other unexpected problems.\n\n   \\param handle handle returned from PHYSFS_open*().\n   \\param bufsize size, in bytes, of buffer to allocate.\n  \\return nonzero if successful, zero on error.\n\n \\sa PHYSFS_flush\n \\sa PHYSFS_read\n \\sa PHYSFS_write\n \\sa PHYSFS_close"]
    pub fn PHYSFS_setBuffer(
        handle: *mut PHYSFS_File,
        bufsize: PHYSFS_uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_flush(PHYSFS_File *handle)\n \\brief Flush a buffered PhysicsFS file handle.\n\n For buffered files opened for writing, this will put the current contents\n  of the buffer to disk and flag the buffer as empty if possible.\n\n For buffered files opened for reading or unbuffered files, this is a safe\n  no-op, and will report success.\n\n   \\param handle handle returned from PHYSFS_open*().\n  \\return nonzero if successful, zero on error.\n\n \\sa PHYSFS_setBuffer\n \\sa PHYSFS_close"]
    pub fn PHYSFS_flush(handle: *mut PHYSFS_File) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint16 PHYSFS_swapSLE16(PHYSFS_sint16 val)\n \\brief Swap littleendian signed 16 to platform's native byte order.\n\n Take a 16-bit signed value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapSLE16(val: PHYSFS_sint16) -> PHYSFS_sint16;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint16 PHYSFS_swapULE16(PHYSFS_uint16 val)\n \\brief Swap littleendian unsigned 16 to platform's native byte order.\n\n Take a 16-bit unsigned value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapULE16(val: PHYSFS_uint16) -> PHYSFS_uint16;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint32 PHYSFS_swapSLE32(PHYSFS_sint32 val)\n \\brief Swap littleendian signed 32 to platform's native byte order.\n\n Take a 32-bit signed value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapSLE32(val: PHYSFS_sint32) -> PHYSFS_sint32;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint32 PHYSFS_swapULE32(PHYSFS_uint32 val)\n \\brief Swap littleendian unsigned 32 to platform's native byte order.\n\n Take a 32-bit unsigned value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapULE32(val: PHYSFS_uint32) -> PHYSFS_uint32;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_swapSLE64(PHYSFS_sint64 val)\n \\brief Swap littleendian signed 64 to platform's native byte order.\n\n Take a 64-bit signed value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value.\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_swapSLE64(val: PHYSFS_sint64) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint64 PHYSFS_swapULE64(PHYSFS_uint64 val)\n \\brief Swap littleendian unsigned 64 to platform's native byte order.\n\n Take a 64-bit unsigned value in littleendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value.\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_swapULE64(val: PHYSFS_uint64) -> PHYSFS_uint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint16 PHYSFS_swapSBE16(PHYSFS_sint16 val)\n \\brief Swap bigendian signed 16 to platform's native byte order.\n\n Take a 16-bit signed value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapSBE16(val: PHYSFS_sint16) -> PHYSFS_sint16;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint16 PHYSFS_swapUBE16(PHYSFS_uint16 val)\n \\brief Swap bigendian unsigned 16 to platform's native byte order.\n\n Take a 16-bit unsigned value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapUBE16(val: PHYSFS_uint16) -> PHYSFS_uint16;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint32 PHYSFS_swapSBE32(PHYSFS_sint32 val)\n \\brief Swap bigendian signed 32 to platform's native byte order.\n\n Take a 32-bit signed value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapSBE32(val: PHYSFS_sint32) -> PHYSFS_sint32;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint32 PHYSFS_swapUBE32(PHYSFS_uint32 val)\n \\brief Swap bigendian unsigned 32 to platform's native byte order.\n\n Take a 32-bit unsigned value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value."]
    pub fn PHYSFS_swapUBE32(val: PHYSFS_uint32) -> PHYSFS_uint32;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_swapSBE64(PHYSFS_sint64 val)\n \\brief Swap bigendian signed 64 to platform's native byte order.\n\n Take a 64-bit signed value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value.\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_swapSBE64(val: PHYSFS_sint64) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_uint64 PHYSFS_swapUBE64(PHYSFS_uint64 val)\n \\brief Swap bigendian unsigned 64 to platform's native byte order.\n\n Take a 64-bit unsigned value in bigendian format and convert it to\n  the platform's native byte order.\n\n    \\param val value to convert\n   \\return converted value.\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_swapUBE64(val: PHYSFS_uint64) -> PHYSFS_uint64;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSLE16(PHYSFS_File *file, PHYSFS_sint16 *val)\n \\brief Read and convert a signed 16-bit littleendian value.\n\n Convenience function. Read a signed 16-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_readSLE16(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readULE16(PHYSFS_File *file, PHYSFS_uint16 *val)\n \\brief Read and convert an unsigned 16-bit littleendian value.\n\n Convenience function. Read an unsigned 16-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n"]
    pub fn PHYSFS_readULE16(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSBE16(PHYSFS_File *file, PHYSFS_sint16 *val)\n \\brief Read and convert a signed 16-bit bigendian value.\n\n Convenience function. Read a signed 16-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_readSBE16(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readUBE16(PHYSFS_File *file, PHYSFS_uint16 *val)\n \\brief Read and convert an unsigned 16-bit bigendian value.\n\n Convenience function. Read an unsigned 16-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n"]
    pub fn PHYSFS_readUBE16(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSLE32(PHYSFS_File *file, PHYSFS_sint32 *val)\n \\brief Read and convert a signed 32-bit littleendian value.\n\n Convenience function. Read a signed 32-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_readSLE32(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readULE32(PHYSFS_File *file, PHYSFS_uint32 *val)\n \\brief Read and convert an unsigned 32-bit littleendian value.\n\n Convenience function. Read an unsigned 32-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n"]
    pub fn PHYSFS_readULE32(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSBE32(PHYSFS_File *file, PHYSFS_sint32 *val)\n \\brief Read and convert a signed 32-bit bigendian value.\n\n Convenience function. Read a signed 32-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_readSBE32(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readUBE32(PHYSFS_File *file, PHYSFS_uint32 *val)\n \\brief Read and convert an unsigned 32-bit bigendian value.\n\n Convenience function. Read an unsigned 32-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n"]
    pub fn PHYSFS_readUBE32(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSLE64(PHYSFS_File *file, PHYSFS_sint64 *val)\n \\brief Read and convert a signed 64-bit littleendian value.\n\n Convenience function. Read a signed 64-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_readSLE64(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readULE64(PHYSFS_File *file, PHYSFS_uint64 *val)\n \\brief Read and convert an unsigned 64-bit littleendian value.\n\n Convenience function. Read an unsigned 64-bit littleendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_readULE64(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readSBE64(PHYSFS_File *file, PHYSFS_sint64 *val)\n \\brief Read and convert a signed 64-bit bigendian value.\n\n Convenience function. Read a signed 64-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_readSBE64(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_sint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_readUBE64(PHYSFS_File *file, PHYSFS_uint64 *val)\n \\brief Read and convert an unsigned 64-bit bigendian value.\n\n Convenience function. Read an unsigned 64-bit bigendian value from a\n  file and convert it to the platform's native byte order.\n\n    \\param file PhysicsFS file handle from which to read.\n    \\param val pointer to where value should be stored.\n   \\return zero on failure, non-zero on success. If successful, (*val) will\n           store the result. On failure, you can find out what went wrong\n           from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_readUBE64(
        file: *mut PHYSFS_File,
        val: *mut PHYSFS_uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSLE16(PHYSFS_File *file, PHYSFS_sint16 val)\n \\brief Convert and write a signed 16-bit littleendian value.\n\n Convenience function. Convert a signed 16-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeSLE16(file: *mut PHYSFS_File, val: PHYSFS_sint16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeULE16(PHYSFS_File *file, PHYSFS_uint16 val)\n \\brief Convert and write an unsigned 16-bit littleendian value.\n\n Convenience function. Convert an unsigned 16-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeULE16(file: *mut PHYSFS_File, val: PHYSFS_uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSBE16(PHYSFS_File *file, PHYSFS_sint16 val)\n \\brief Convert and write a signed 16-bit bigendian value.\n\n Convenience function. Convert a signed 16-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeSBE16(file: *mut PHYSFS_File, val: PHYSFS_sint16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeUBE16(PHYSFS_File *file, PHYSFS_uint16 val)\n \\brief Convert and write an unsigned 16-bit bigendian value.\n\n Convenience function. Convert an unsigned 16-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeUBE16(file: *mut PHYSFS_File, val: PHYSFS_uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSLE32(PHYSFS_File *file, PHYSFS_sint32 val)\n \\brief Convert and write a signed 32-bit littleendian value.\n\n Convenience function. Convert a signed 32-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeSLE32(file: *mut PHYSFS_File, val: PHYSFS_sint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeULE32(PHYSFS_File *file, PHYSFS_uint32 val)\n \\brief Convert and write an unsigned 32-bit littleendian value.\n\n Convenience function. Convert an unsigned 32-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeULE32(file: *mut PHYSFS_File, val: PHYSFS_uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSBE32(PHYSFS_File *file, PHYSFS_sint32 val)\n \\brief Convert and write a signed 32-bit bigendian value.\n\n Convenience function. Convert a signed 32-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeSBE32(file: *mut PHYSFS_File, val: PHYSFS_sint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeUBE32(PHYSFS_File *file, PHYSFS_uint32 val)\n \\brief Convert and write an unsigned 32-bit bigendian value.\n\n Convenience function. Convert an unsigned 32-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode()."]
    pub fn PHYSFS_writeUBE32(file: *mut PHYSFS_File, val: PHYSFS_uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSLE64(PHYSFS_File *file, PHYSFS_sint64 val)\n \\brief Convert and write a signed 64-bit littleendian value.\n\n Convenience function. Convert a signed 64-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_writeSLE64(file: *mut PHYSFS_File, val: PHYSFS_sint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeULE64(PHYSFS_File *file, PHYSFS_uint64 val)\n \\brief Convert and write an unsigned 64-bit littleendian value.\n\n Convenience function. Convert an unsigned 64-bit value from the platform's\n  native byte order to littleendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_writeULE64(file: *mut PHYSFS_File, val: PHYSFS_uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeSBE64(PHYSFS_File *file, PHYSFS_sint64 val)\n \\brief Convert and write a signed 64-bit bigending value.\n\n Convenience function. Convert a signed 64-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_sint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_writeSBE64(file: *mut PHYSFS_File, val: PHYSFS_sint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_writeUBE64(PHYSFS_File *file, PHYSFS_uint64 val)\n \\brief Convert and write an unsigned 64-bit bigendian value.\n\n Convenience function. Convert an unsigned 64-bit value from the platform's\n  native byte order to bigendian and write it to a file.\n\n    \\param file PhysicsFS file handle to which to write.\n    \\param val Value to convert and write.\n   \\return zero on failure, non-zero on success. On failure, you can\n           find out what went wrong from PHYSFS_getLastErrorCode().\n\n \\warning Remember, PHYSFS_uint64 is only 32 bits on platforms without\n          any sort of 64-bit support."]
    pub fn PHYSFS_writeUBE64(file: *mut PHYSFS_File, val: PHYSFS_uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_isInit(void)\n \\brief Determine if the PhysicsFS library is initialized.\n\n Once PHYSFS_init() returns successfully, this will return non-zero.\n  Before a successful PHYSFS_init() and after PHYSFS_deinit() returns\n  successfully, this will return zero. This function is safe to call at\n  any time.\n\n  \\return non-zero if library is initialized, zero if library is not.\n\n \\sa PHYSFS_init\n \\sa PHYSFS_deinit"]
    pub fn PHYSFS_isInit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_symbolicLinksPermitted(void)\n \\brief Determine if the symbolic links are permitted.\n\n This reports the setting from the last call to PHYSFS_permitSymbolicLinks().\n  If PHYSFS_permitSymbolicLinks() hasn't been called since the library was\n  last initialized, symbolic links are implicitly disabled.\n\n  \\return non-zero if symlinks are permitted, zero if not.\n\n \\sa PHYSFS_permitSymbolicLinks"]
    pub fn PHYSFS_symbolicLinksPermitted() -> ::std::os::raw::c_int;
}
#[doc = " \\struct PHYSFS_Allocator\n \\brief PhysicsFS allocation function pointers.\n\n (This is for limited, hardcore use. If you don't immediately see a need\n  for it, you can probably ignore this forever.)\n\n You create one of these structures for use with PHYSFS_setAllocator.\n  Allocators are assumed to be reentrant by the caller; please mutex\n  accordingly.\n\n Allocations are always discussed in 64-bits, for future expansion...we're\n  on the cusp of a 64-bit transition, and we'll probably be allocating 6\n  gigabytes like it's nothing sooner or later, and I don't want to change\n  this again at that point. If you're on a 32-bit platform and have to\n  downcast, it's okay to return NULL if the allocation is greater than\n  4 gigabytes, since you'd have to do so anyhow.\n\n \\sa PHYSFS_setAllocator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_Allocator {
    #[doc = "< Initialize. Can be NULL. Zero on failure."]
    pub Init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    #[doc = "< Deinitialize your allocator. Can be NULL."]
    pub Deinit: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "< Allocate like malloc()."]
    pub Malloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: PHYSFS_uint64) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = "< Reallocate like realloc()."]
    pub Realloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: PHYSFS_uint64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = "< Free memory from Malloc or Realloc."]
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_PHYSFS_Allocator() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_Allocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_Allocator>(),
        40usize,
        concat!("Size of: ", stringify!(PHYSFS_Allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_Allocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Allocator),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Deinit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Allocator),
            "::",
            stringify!(Deinit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Malloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Allocator),
            "::",
            stringify!(Malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Realloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Allocator),
            "::",
            stringify!(Realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Allocator),
            "::",
            stringify!(Free)
        )
    );
}
extern "C" {
    #[doc = " \\fn int PHYSFS_setAllocator(const PHYSFS_Allocator *allocator)\n \\brief Hook your own allocation routines into PhysicsFS.\n\n (This is for limited, hardcore use. If you don't immediately see a need\n  for it, you can probably ignore this forever.)\n\n By default, PhysicsFS will use whatever is reasonable for a platform\n  to manage dynamic memory (usually ANSI C malloc/realloc/free, but\n  some platforms might use something else), but in some uncommon cases, the\n  app might want more control over the library's memory management. This\n  lets you redirect PhysicsFS to use your own allocation routines instead.\n  You can only call this function before PHYSFS_init(); if the library is\n  initialized, it'll reject your efforts to change the allocator mid-stream.\n  You may call this function after PHYSFS_deinit() if you are willing to\n  shut down the library and restart it with a new allocator; this is a safe\n  and supported operation. The allocator remains intact between deinit/init\n  calls. If you want to return to the platform's default allocator, pass a\n  NULL in here.\n\n If you aren't immediately sure what to do with this function, you can\n  safely ignore it altogether.\n\n    \\param allocator Structure containing your allocator's entry points.\n   \\return zero on failure, non-zero on success. This call only fails\n           when used between PHYSFS_init() and PHYSFS_deinit() calls."]
    pub fn PHYSFS_setAllocator(allocator: *const PHYSFS_Allocator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_mount(const char *newDir, const char *mountPoint, int appendToPath)\n \\brief Add an archive or directory to the search path.\n\n If this is a duplicate, the entry is not added again, even though the\n  function succeeds. You may not add the same archive to two different\n  mountpoints: duplicate checking is done against the archive and not the\n  mountpoint.\n\n When you mount an archive, it is added to a virtual file system...all files\n  in all of the archives are interpolated into a single hierachical file\n  tree. Two archives mounted at the same place (or an archive with files\n  overlapping another mountpoint) may have overlapping files: in such a case,\n  the file earliest in the search path is selected, and the other files are\n  inaccessible to the application. This allows archives to be used to\n  override previous revisions; you can use the mounting mechanism to place\n  archives at a specific point in the file tree and prevent overlap; this\n  is useful for downloadable mods that might trample over application data\n  or each other, for example.\n\n The mountpoint does not need to exist prior to mounting, which is different\n  than those familiar with the Unix concept of \"mounting\" may expect.\n  As well, more than one archive can be mounted to the same mountpoint, or\n  mountpoints and archive contents can overlap...the interpolation mechanism\n  still functions as usual.\n\n Specifying a symbolic link to an archive or directory is allowed here,\n  regardless of the state of PHYSFS_permitSymbolicLinks(). That function\n  only deals with symlinks inside the mounted directory or archive.\n\n   \\param newDir directory or archive to add to the path, in\n                   platform-dependent notation.\n   \\param mountPoint Location in the interpolated tree that this archive\n                     will be \"mounted\", in platform-independent notation.\n                     NULL or \"\" is equivalent to \"/\".\n   \\param appendToPath nonzero to append to search path, zero to prepend.\n  \\return nonzero if added to path, zero on failure (bogus archive, dir\n          missing, etc). Use PHYSFS_getLastErrorCode() to obtain\n          the specific error.\n\n \\sa PHYSFS_removeFromSearchPath\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_getMountPoint\n \\sa PHYSFS_mountIo"]
    pub fn PHYSFS_mount(
        newDir: *const ::std::os::raw::c_char,
        mountPoint: *const ::std::os::raw::c_char,
        appendToPath: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_getMountPoint(const char *dir)\n \\brief Determine a mounted archive's mountpoint.\n\n You give this function the name of an archive or dir you successfully\n  added to the search path, and it reports the location in the interpolated\n  tree where it is mounted. Files mounted with a NULL mountpoint or through\n  PHYSFS_addToSearchPath() will report \"/\". The return value is READ ONLY\n  and valid until the archive is removed from the search path.\n\n   \\param dir directory or archive previously added to the path, in\n              platform-dependent notation. This must match the string\n              used when adding, even if your string would also reference\n              the same file with a different string of characters.\n  \\return READ-ONLY string of mount point if added to path, NULL on failure\n          (bogus archive, etc). Use PHYSFS_getLastErrorCode() to obtain the\n          specific error.\n\n \\sa PHYSFS_removeFromSearchPath\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_getMountPoint"]
    pub fn PHYSFS_getMountPoint(
        dir: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " \\typedef PHYSFS_StringCallback\n \\brief Function signature for callbacks that report strings.\n\n These are used to report a list of strings to an original caller, one\n  string per callback. All strings are UTF-8 encoded. Functions should not\n  try to modify or free the string's memory.\n\n These callbacks are used, starting in PhysicsFS 1.1, as an alternative to\n  functions that would return lists that need to be cleaned up with\n  PHYSFS_freeList(). The callback means that the library doesn't need to\n  allocate an entire list and all the strings up front.\n\n Be aware that promises data ordering in the list versions are not\n  necessarily so in the callback versions. Check the documentation on\n  specific APIs, but strings may not be sorted as you expect.\n\n    \\param data User-defined data pointer, passed through from the API\n                that eventually called the callback.\n    \\param str The string data about which the callback is meant to inform.\n\n \\sa PHYSFS_getCdRomDirsCallback\n \\sa PHYSFS_getSearchPathCallback"]
pub type PHYSFS_StringCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, str_: *const ::std::os::raw::c_char),
>;
#[doc = " \\typedef PHYSFS_EnumFilesCallback\n \\brief Function signature for callbacks that enumerate files.\n\n \\warning As of PhysicsFS 2.1, Use PHYSFS_EnumerateCallback with\n  PHYSFS_enumerate() instead; it gives you more control over the process.\n\n These are used to report a list of directory entries to an original caller,\n  one file/dir/symlink per callback. All strings are UTF-8 encoded.\n  Functions should not try to modify or free any string's memory.\n\n These callbacks are used, starting in PhysicsFS 1.1, as an alternative to\n  functions that would return lists that need to be cleaned up with\n  PHYSFS_freeList(). The callback means that the library doesn't need to\n  allocate an entire list and all the strings up front.\n\n Be aware that promised data ordering in the list versions are not\n  necessarily so in the callback versions. Check the documentation on\n  specific APIs, but strings may not be sorted as you expect and you might\n  get duplicate strings.\n\n    \\param data User-defined data pointer, passed through from the API\n                that eventually called the callback.\n    \\param origdir A string containing the full path, in platform-independent\n                   notation, of the directory containing this file. In most\n                   cases, this is the directory on which you requested\n                   enumeration, passed in the callback for your convenience.\n    \\param fname The filename that is being enumerated. It may not be in\n                 alphabetical order compared to other callbacks that have\n                 fired, and it will not contain the full path. You can\n                 recreate the fullpath with $origdir/$fname ... The file\n                 can be a subdirectory, a file, a symlink, etc.\n\n \\sa PHYSFS_enumerateFilesCallback"]
pub type PHYSFS_EnumFilesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        origdir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " \\fn void PHYSFS_getCdRomDirsCallback(PHYSFS_StringCallback c, void *d)\n \\brief Enumerate CD-ROM directories, using an application-defined callback.\n\n Internally, PHYSFS_getCdRomDirs() just calls this function and then builds\n  a list before returning to the application, so functionality is identical\n  except for how the information is represented to the application.\n\n Unlike PHYSFS_getCdRomDirs(), this function does not return an array.\n  Rather, it calls a function specified by the application once per\n  detected disc:\n\n \\code\n\n static void foundDisc(void *data, const char *cddir)\n {\n     printf(\"cdrom dir [%s] is available.\\n\", cddir);\n }\n\n // ...\n PHYSFS_getCdRomDirsCallback(foundDisc, NULL);\n \\endcode\n\n This call may block while drives spin up. Be forewarned.\n\n    \\param c Callback function to notify about detected drives.\n    \\param d Application-defined data passed to callback. Can be NULL.\n\n \\sa PHYSFS_StringCallback\n \\sa PHYSFS_getCdRomDirs"]
    pub fn PHYSFS_getCdRomDirsCallback(c: PHYSFS_StringCallback, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\fn void PHYSFS_getSearchPathCallback(PHYSFS_StringCallback c, void *d)\n \\brief Enumerate the search path, using an application-defined callback.\n\n Internally, PHYSFS_getSearchPath() just calls this function and then builds\n  a list before returning to the application, so functionality is identical\n  except for how the information is represented to the application.\n\n Unlike PHYSFS_getSearchPath(), this function does not return an array.\n  Rather, it calls a function specified by the application once per\n  element of the search path:\n\n \\code\n\n static void printSearchPath(void *data, const char *pathItem)\n {\n     printf(\"[%s] is in the search path.\\n\", pathItem);\n }\n\n // ...\n PHYSFS_getSearchPathCallback(printSearchPath, NULL);\n \\endcode\n\n Elements of the search path are reported in order search priority, so the\n  first archive/dir that would be examined when looking for a file is the\n  first element passed through the callback.\n\n    \\param c Callback function to notify about search path elements.\n    \\param d Application-defined data passed to callback. Can be NULL.\n\n \\sa PHYSFS_StringCallback\n \\sa PHYSFS_getSearchPath"]
    pub fn PHYSFS_getSearchPathCallback(c: PHYSFS_StringCallback, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\fn void PHYSFS_enumerateFilesCallback(const char *dir, PHYSFS_EnumFilesCallback c, void *d)\n \\brief Get a file listing of a search path's directory, using an application-defined callback.\n\n \\deprecated As of PhysicsFS 2.1, use PHYSFS_enumerate() instead. This\n  function has no way to report errors (or to have the callback signal an\n  error or request a stop), so if data will be lost, your callback has no\n  way to direct the process, and your calling app has no way to know.\n\n As of PhysicsFS 2.1, this function just wraps PHYSFS_enumerate() and\n  ignores errors. Consider using PHYSFS_enumerate() or\n  PHYSFS_enumerateFiles() instead.\n\n \\sa PHYSFS_enumerate\n \\sa PHYSFS_enumerateFiles\n \\sa PHYSFS_EnumFilesCallback"]
    pub fn PHYSFS_enumerateFilesCallback(
        dir: *const ::std::os::raw::c_char,
        c: PHYSFS_EnumFilesCallback,
        d: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\fn void PHYSFS_utf8FromUcs4(const PHYSFS_uint32 *src, char *dst, PHYSFS_uint64 len)\n \\brief Convert a UCS-4 string to a UTF-8 string.\n\n \\warning This function will not report an error if there are invalid UCS-4\n          values in the source string. It will replace them with a '?'\n          character and continue on.\n\n UCS-4 (aka UTF-32) strings are 32-bits per character: \\c wchar_t on Unix.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is the same size as the source buffer. UTF-8\n  never uses more than 32-bits per character, so while it may shrink a UCS-4\n  string, it will never expand it.\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UTF-8\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n   \\param src Null-terminated source string in UCS-4 format.\n   \\param dst Buffer to store converted UTF-8 string.\n   \\param len Size, in bytes, of destination buffer."]
    pub fn PHYSFS_utf8FromUcs4(
        src: *const PHYSFS_uint32,
        dst: *mut ::std::os::raw::c_char,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn void PHYSFS_utf8ToUcs4(const char *src, PHYSFS_uint32 *dst, PHYSFS_uint64 len)\n \\brief Convert a UTF-8 string to a UCS-4 string.\n\n \\warning This function will not report an error if there are invalid UTF-8\n          sequences in the source string. It will replace them with a '?'\n          character and continue on.\n\n UCS-4 (aka UTF-32) strings are 32-bits per character: \\c wchar_t on Unix.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is four times the size of the source buffer.\n  UTF-8 uses from one to four bytes per character, but UCS-4 always uses\n  four, so an entirely low-ASCII string will quadruple in size!\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UCS-4\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n   \\param src Null-terminated source string in UTF-8 format.\n   \\param dst Buffer to store converted UCS-4 string.\n   \\param len Size, in bytes, of destination buffer."]
    pub fn PHYSFS_utf8ToUcs4(
        src: *const ::std::os::raw::c_char,
        dst: *mut PHYSFS_uint32,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn void PHYSFS_utf8FromUcs2(const PHYSFS_uint16 *src, char *dst, PHYSFS_uint64 len)\n \\brief Convert a UCS-2 string to a UTF-8 string.\n\n \\warning you almost certainly should use PHYSFS_utf8FromUtf16(), which\n  became available in PhysicsFS 2.1, unless you know what you're doing.\n\n \\warning This function will not report an error if there are invalid UCS-2\n          values in the source string. It will replace them with a '?'\n          character and continue on.\n\n UCS-2 strings are 16-bits per character: \\c TCHAR on Windows, when building\n  with Unicode support. Please note that modern versions of Windows use\n  UTF-16, which is an extended form of UCS-2, and not UCS-2 itself. You\n  almost certainly want PHYSFS_utf8FromUtf16() instead.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is double the size of the source buffer.\n  UTF-8 never uses more than 32-bits per character, so while it may shrink\n  a UCS-2 string, it may also expand it.\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UTF-8\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n   \\param src Null-terminated source string in UCS-2 format.\n   \\param dst Buffer to store converted UTF-8 string.\n   \\param len Size, in bytes, of destination buffer.\n\n \\sa PHYSFS_utf8FromUtf16"]
    pub fn PHYSFS_utf8FromUcs2(
        src: *const PHYSFS_uint16,
        dst: *mut ::std::os::raw::c_char,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn PHYSFS_utf8ToUcs2(const char *src, PHYSFS_uint16 *dst, PHYSFS_uint64 len)\n \\brief Convert a UTF-8 string to a UCS-2 string.\n\n \\warning you almost certainly should use PHYSFS_utf8ToUtf16(), which\n  became available in PhysicsFS 2.1, unless you know what you're doing.\n\n \\warning This function will not report an error if there are invalid UTF-8\n          sequences in the source string. It will replace them with a '?'\n          character and continue on.\n\n UCS-2 strings are 16-bits per character: \\c TCHAR on Windows, when building\n  with Unicode support. Please note that modern versions of Windows use\n  UTF-16, which is an extended form of UCS-2, and not UCS-2 itself. You\n  almost certainly want PHYSFS_utf8ToUtf16() instead, but you need to\n  understand how that changes things, too.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is double the size of the source buffer.\n  UTF-8 uses from one to four bytes per character, but UCS-2 always uses\n  two, so an entirely low-ASCII string will double in size!\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UCS-2\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n   \\param src Null-terminated source string in UTF-8 format.\n   \\param dst Buffer to store converted UCS-2 string.\n   \\param len Size, in bytes, of destination buffer.\n\n \\sa PHYSFS_utf8ToUtf16"]
    pub fn PHYSFS_utf8ToUcs2(
        src: *const ::std::os::raw::c_char,
        dst: *mut PHYSFS_uint16,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn void PHYSFS_utf8FromLatin1(const char *src, char *dst, PHYSFS_uint64 len)\n \\brief Convert a UTF-8 string to a Latin1 string.\n\n Latin1 strings are 8-bits per character: a popular \"high ASCII\" encoding.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is double the size of the source buffer.\n  UTF-8 expands latin1 codepoints over 127 from 1 to 2 bytes, so the string\n  may grow in some cases.\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UTF-8\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n Please note that we do not supply a UTF-8 to Latin1 converter, since Latin1\n  can't express most Unicode codepoints. It's a legacy encoding; you should\n  be converting away from it at all times.\n\n   \\param src Null-terminated source string in Latin1 format.\n   \\param dst Buffer to store converted UTF-8 string.\n   \\param len Size, in bytes, of destination buffer."]
    pub fn PHYSFS_utf8FromLatin1(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn int PHYSFS_caseFold(const PHYSFS_uint32 from, PHYSFS_uint32 *to)\n \\brief \"Fold\" a Unicode codepoint to a lowercase equivalent.\n\n (This is for limited, hardcore use. If you don't immediately see a need\n  for it, you can probably ignore this forever.)\n\n This will convert a Unicode codepoint into its lowercase equivalent.\n  Bogus codepoints and codepoints without a lowercase equivalent will\n  be returned unconverted.\n\n Note that you might get multiple codepoints in return! The German Eszett,\n  for example, will fold down to two lowercase latin 's' codepoints. The\n  theory is that if you fold two strings, one with an Eszett and one with\n  \"SS\" down, they will match.\n\n \\warning Anyone that is a student of Unicode knows about the \"Turkish I\"\n          problem. This API does not handle it. Assume this one letter\n          in all of Unicode will definitely fold sort of incorrectly. If\n          you don't know what this is about, you can probably ignore this\n          problem for most of the planet, but perfection is impossible.\n\n   \\param from The codepoint to fold.\n   \\param to Buffer to store the folded codepoint values into. This should\n             point to space for at least 3 PHYSFS_uint32 slots.\n  \\return The number of codepoints the folding produced. Between 1 and 3."]
    pub fn PHYSFS_caseFold(from: PHYSFS_uint32, to: *mut PHYSFS_uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_utf8stricmp(const char *str1, const char *str2)\n \\brief Case-insensitive compare of two UTF-8 strings.\n\n This is a strcasecmp/stricmp replacement that expects both strings\n  to be in UTF-8 encoding. It will do \"case folding\" to decide if the\n  Unicode codepoints in the strings match.\n\n If both strings are exclusively low-ASCII characters, this will do the\n  right thing, as that is also valid UTF-8. If there are any high-ASCII\n  chars, this will not do what you expect!\n\n It will report which string is \"greater than\" the other, but be aware that\n  this doesn't necessarily mean anything: 'a' may be \"less than\" 'b', but\n  a Japanese kuten has no meaningful alphabetically relationship to\n  a Greek lambda, but being able to assign a reliable \"value\" makes sorting\n  algorithms possible, if not entirely sane. Most cases should treat the\n  return value as \"equal\" or \"not equal\".\n\n Like stricmp, this expects both strings to be NULL-terminated.\n\n   \\param str1 First string to compare.\n   \\param str2 Second string to compare.\n  \\return -1 if str1 is \"less than\" str2, 1 if \"greater than\", 0 if equal."]
    pub fn PHYSFS_utf8stricmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_utf16stricmp(const PHYSFS_uint16 *str1, const PHYSFS_uint16 *str2)\n \\brief Case-insensitive compare of two UTF-16 strings.\n\n This is a strcasecmp/stricmp replacement that expects both strings\n  to be in UTF-16 encoding. It will do \"case folding\" to decide if the\n  Unicode codepoints in the strings match.\n\n It will report which string is \"greater than\" the other, but be aware that\n  this doesn't necessarily mean anything: 'a' may be \"less than\" 'b', but\n  a Japanese kuten has no meaningful alphabetically relationship to\n  a Greek lambda, but being able to assign a reliable \"value\" makes sorting\n  algorithms possible, if not entirely sane. Most cases should treat the\n  return value as \"equal\" or \"not equal\".\n\n Like stricmp, this expects both strings to be NULL-terminated.\n\n   \\param str1 First string to compare.\n   \\param str2 Second string to compare.\n  \\return -1 if str1 is \"less than\" str2, 1 if \"greater than\", 0 if equal."]
    pub fn PHYSFS_utf16stricmp(
        str1: *const PHYSFS_uint16,
        str2: *const PHYSFS_uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_ucs4stricmp(const PHYSFS_uint32 *str1, const PHYSFS_uint32 *str2)\n \\brief Case-insensitive compare of two UCS-4 strings.\n\n This is a strcasecmp/stricmp replacement that expects both strings\n  to be in UCS-4 (aka UTF-32) encoding. It will do \"case folding\" to decide\n  if the Unicode codepoints in the strings match.\n\n It will report which string is \"greater than\" the other, but be aware that\n  this doesn't necessarily mean anything: 'a' may be \"less than\" 'b', but\n  a Japanese kuten has no meaningful alphabetically relationship to\n  a Greek lambda, but being able to assign a reliable \"value\" makes sorting\n  algorithms possible, if not entirely sane. Most cases should treat the\n  return value as \"equal\" or \"not equal\".\n\n Like stricmp, this expects both strings to be NULL-terminated.\n\n   \\param str1 First string to compare.\n   \\param str2 Second string to compare.\n  \\return -1 if str1 is \"less than\" str2, 1 if \"greater than\", 0 if equal."]
    pub fn PHYSFS_ucs4stricmp(
        str1: *const PHYSFS_uint32,
        str2: *const PHYSFS_uint32,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Stop enumerating, report error to app."]
pub const PHYSFS_EnumerateCallbackResult_PHYSFS_ENUM_ERROR: PHYSFS_EnumerateCallbackResult = -1;
#[doc = "< Stop enumerating, report success to app."]
pub const PHYSFS_EnumerateCallbackResult_PHYSFS_ENUM_STOP: PHYSFS_EnumerateCallbackResult = 0;
#[doc = "< Keep enumerating, no problems"]
pub const PHYSFS_EnumerateCallbackResult_PHYSFS_ENUM_OK: PHYSFS_EnumerateCallbackResult = 1;
#[doc = " \\typedef PHYSFS_EnumerateCallback\n \\brief Possible return values from PHYSFS_EnumerateCallback.\n\n These values dictate if an enumeration callback should continue to fire,\n  or stop (and why it is stopping).\n\n \\sa PHYSFS_EnumerateCallback\n \\sa PHYSFS_enumerate"]
pub type PHYSFS_EnumerateCallbackResult = ::std::os::raw::c_int;
#[doc = " \\typedef PHYSFS_EnumerateCallback\n \\brief Function signature for callbacks that enumerate and return results.\n\n This is the same thing as PHYSFS_EnumFilesCallback from PhysicsFS 2.0,\n  except it can return a result from the callback: namely: if you're looking\n  for something specific, once you find it, you can tell PhysicsFS to stop\n  enumerating further. This is used with PHYSFS_enumerate(), which we\n  hopefully got right this time.  :)\n\n    \\param data User-defined data pointer, passed through from the API\n                that eventually called the callback.\n    \\param origdir A string containing the full path, in platform-independent\n                   notation, of the directory containing this file. In most\n                   cases, this is the directory on which you requested\n                   enumeration, passed in the callback for your convenience.\n    \\param fname The filename that is being enumerated. It may not be in\n                 alphabetical order compared to other callbacks that have\n                 fired, and it will not contain the full path. You can\n                 recreate the fullpath with $origdir/$fname ... The file\n                 can be a subdirectory, a file, a symlink, etc.\n   \\return A value from PHYSFS_EnumerateCallbackResult.\n           All other values are (currently) undefined; don't use them.\n\n \\sa PHYSFS_enumerate\n \\sa PHYSFS_EnumerateCallbackResult"]
pub type PHYSFS_EnumerateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        origdir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> PHYSFS_EnumerateCallbackResult,
>;
extern "C" {
    #[doc = " \\fn int PHYSFS_enumerate(const char *dir, PHYSFS_EnumerateCallback c, void *d)\n \\brief Get a file listing of a search path's directory, using an application-defined callback, with errors reported.\n\n Internally, PHYSFS_enumerateFiles() just calls this function and then builds\n  a list before returning to the application, so functionality is identical\n  except for how the information is represented to the application.\n\n Unlike PHYSFS_enumerateFiles(), this function does not return an array.\n  Rather, it calls a function specified by the application once per\n  element of the search path:\n\n \\code\n\n static int printDir(void *data, const char *origdir, const char *fname)\n {\n     printf(\" * We've got [%s] in [%s].\\n\", fname, origdir);\n     return 1;  // give me more data, please.\n }\n\n // ...\n PHYSFS_enumerate(\"/some/path\", printDir, NULL);\n \\endcode\n\n Items sent to the callback are not guaranteed to be in any order whatsoever.\n  There is no sorting done at this level, and if you need that, you should\n  probably use PHYSFS_enumerateFiles() instead, which guarantees\n  alphabetical sorting. This form reports whatever is discovered in each\n  archive before moving on to the next. Even within one archive, we can't\n  guarantee what order it will discover data. <em>Any sorting you find in\n  these callbacks is just pure luck. Do not rely on it.</em> As this walks\n  the entire list of archives, you may receive duplicate filenames.\n\n This API and the callbacks themselves are capable of reporting errors.\n  Prior to this API, callbacks had to accept every enumerated item, even if\n  they were only looking for a specific thing and wanted to stop after that,\n  or had a serious error and couldn't alert anyone. Furthermore, if\n  PhysicsFS itself had a problem (disk error or whatnot), it couldn't report\n  it to the calling app, it would just have to skip items or stop\n  enumerating outright, and the caller wouldn't know it had lost some data\n  along the way.\n\n Now the caller can be sure it got a complete data set, and its callback has\n  control if it wants enumeration to stop early. See the documentation for\n  PHYSFS_EnumerateCallback for details on how your callback should behave.\n\n    \\param dir Directory, in platform-independent notation, to enumerate.\n    \\param c Callback function to notify about search path elements.\n    \\param d Application-defined data passed to callback. Can be NULL.\n   \\return non-zero on success, zero on failure. Use\n           PHYSFS_getLastErrorCode() to obtain the specific error. If the\n           callback returns PHYSFS_ENUM_STOP to stop early, this will be\n           considered success. Callbacks returning PHYSFS_ENUM_ERROR will\n           make this function return zero and set the error code to\n           PHYSFS_ERR_APP_CALLBACK.\n\n \\sa PHYSFS_EnumerateCallback\n \\sa PHYSFS_enumerateFiles"]
    pub fn PHYSFS_enumerate(
        dir: *const ::std::os::raw::c_char,
        c: PHYSFS_EnumerateCallback,
        d: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_unmount(const char *oldDir)\n \\brief Remove a directory or archive from the search path.\n\n This is functionally equivalent to PHYSFS_removeFromSearchPath(), but that\n  function is deprecated to keep the vocabulary paired with PHYSFS_mount().\n\n This must be a (case-sensitive) match to a dir or archive already in the\n  search path, specified in platform-dependent notation.\n\n This call will fail (and fail to remove from the path) if the element still\n  has files open in it.\n\n \\warning This function wants the path to the archive or directory that was\n          mounted (the same string used for the \"newDir\" argument of\n          PHYSFS_addToSearchPath or any of the mount functions), not the\n          path where it is mounted in the tree (the \"mountPoint\" argument\n          to any of the mount functions).\n\n    \\param oldDir dir/archive to remove.\n   \\return nonzero on success, zero on failure. Use\n           PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_mount"]
    pub fn PHYSFS_unmount(oldDir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn const PHYSFS_Allocator *PHYSFS_getAllocator(void)\n \\brief Discover the current allocator.\n\n (This is for limited, hardcore use. If you don't immediately see a need\n  for it, you can probably ignore this forever.)\n\n This function exposes the function pointers that make up the currently used\n  allocator. This can be useful for apps that want to access PhysicsFS's\n  internal, default allocation routines, as well as for external code that\n  wants to share the same allocator, even if the application specified their\n  own.\n\n This call is only valid between PHYSFS_init() and PHYSFS_deinit() calls;\n  it will return NULL if the library isn't initialized. As we can't\n  guarantee the state of the internal allocators unless the library is\n  initialized, you shouldn't use any allocator returned here after a call\n  to PHYSFS_deinit().\n\n Do not call the returned allocator's Init() or Deinit() methods under any\n  circumstances.\n\n If you aren't immediately sure what to do with this function, you can\n  safely ignore it altogether.\n\n  \\return Current allocator, as set by PHYSFS_setAllocator(), or PhysicsFS's\n          internal, default allocator if no application defined allocator\n          is currently set. Will return NULL if the library is not\n          initialized.\n\n \\sa PHYSFS_Allocator\n \\sa PHYSFS_setAllocator"]
    pub fn PHYSFS_getAllocator() -> *const PHYSFS_Allocator;
}
#[doc = "< a normal file"]
pub const PHYSFS_FileType_PHYSFS_FILETYPE_REGULAR: PHYSFS_FileType = 0;
#[doc = "< a directory"]
pub const PHYSFS_FileType_PHYSFS_FILETYPE_DIRECTORY: PHYSFS_FileType = 1;
#[doc = "< a symlink"]
pub const PHYSFS_FileType_PHYSFS_FILETYPE_SYMLINK: PHYSFS_FileType = 2;
#[doc = "< something completely different like a device"]
pub const PHYSFS_FileType_PHYSFS_FILETYPE_OTHER: PHYSFS_FileType = 3;
#[doc = " \\enum PHYSFS_FileType\n \\brief Type of a File\n\n Possible types of a file.\n\n \\sa PHYSFS_stat"]
pub type PHYSFS_FileType = ::std::os::raw::c_uint;
#[doc = " \\struct PHYSFS_Stat\n \\brief Meta data for a file or directory\n\n Container for various meta data about a file in the virtual file system.\n  PHYSFS_stat() uses this structure for returning the information. The time\n  data will be either the number of seconds since the Unix epoch (midnight,\n  Jan 1, 1970), or -1 if the information isn't available or applicable.\n  The (filesize) field is measured in bytes.\n  The (readonly) field tells you whether the archive thinks a file is\n  not writable, but tends to be only an estimate (for example, your write\n  dir might overlap with a .zip file, meaning you _can_ successfully open\n  that path for writing, as it gets created elsewhere.\n\n \\sa PHYSFS_stat\n \\sa PHYSFS_FileType"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_Stat {
    #[doc = "< size in bytes, -1 for non-files and unknown"]
    pub filesize: PHYSFS_sint64,
    #[doc = "< last modification time"]
    pub modtime: PHYSFS_sint64,
    #[doc = "< like modtime, but for file creation time"]
    pub createtime: PHYSFS_sint64,
    #[doc = "< like modtime, but for file access time"]
    pub accesstime: PHYSFS_sint64,
    #[doc = "< File? Directory? Symlink?"]
    pub filetype: PHYSFS_FileType,
    #[doc = "< non-zero if read only, zero if writable."]
    pub readonly: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PHYSFS_Stat() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_Stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_Stat>(),
        40usize,
        concat!("Size of: ", stringify!(PHYSFS_Stat))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_Stat>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_Stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filesize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(filesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(modtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).createtime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(createtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accesstime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(accesstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readonly) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Stat),
            "::",
            stringify!(readonly)
        )
    );
}
extern "C" {
    #[doc = " \\fn int PHYSFS_stat(const char *fname, PHYSFS_Stat *stat)\n \\brief Get various information about a directory or a file.\n\n Obtain various information about a file or directory from the meta data.\n\n This function will never follow symbolic links. If you haven't enabled\n  symlinks with PHYSFS_permitSymbolicLinks(), stat'ing a symlink will be\n  treated like stat'ing a non-existant file. If symlinks are enabled,\n  stat'ing a symlink will give you information on the link itself and not\n  what it points to.\n\n    \\param fname filename to check, in platform-indepedent notation.\n    \\param stat pointer to structure to fill in with data about (fname).\n   \\return non-zero on success, zero on failure. On failure, (stat)'s\n           contents are undefined.\n\n \\sa PHYSFS_Stat"]
    pub fn PHYSFS_stat(
        fname: *const ::std::os::raw::c_char,
        stat: *mut PHYSFS_Stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn void PHYSFS_utf8FromUtf16(const PHYSFS_uint16 *src, char *dst, PHYSFS_uint64 len)\n \\brief Convert a UTF-16 string to a UTF-8 string.\n\n \\warning This function will not report an error if there are invalid UTF-16\n          sequences in the source string. It will replace them with a '?'\n          character and continue on.\n\n UTF-16 strings are 16-bits per character (except some chars, which are\n  32-bits): \\c TCHAR on Windows, when building with Unicode support. Modern\n  Windows releases use UTF-16. Windows releases before 2000 used TCHAR, but\n  only handled UCS-2. UTF-16 _is_ UCS-2, except for the characters that\n  are 4 bytes, which aren't representable in UCS-2 at all anyhow. If you\n  aren't sure, you should be using UTF-16 at this point on Windows.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is double the size of the source buffer.\n  UTF-8 never uses more than 32-bits per character, so while it may shrink\n  a UTF-16 string, it may also expand it.\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UTF-8\n  sequence at the end. If the buffer length is 0, this function does nothing.\n\n   \\param src Null-terminated source string in UTF-16 format.\n   \\param dst Buffer to store converted UTF-8 string.\n   \\param len Size, in bytes, of destination buffer."]
    pub fn PHYSFS_utf8FromUtf16(
        src: *const PHYSFS_uint16,
        dst: *mut ::std::os::raw::c_char,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn PHYSFS_utf8ToUtf16(const char *src, PHYSFS_uint16 *dst, PHYSFS_uint64 len)\n \\brief Convert a UTF-8 string to a UTF-16 string.\n\n \\warning This function will not report an error if there are invalid UTF-8\n          sequences in the source string. It will replace them with a '?'\n          character and continue on.\n\n UTF-16 strings are 16-bits per character (except some chars, which are\n  32-bits): \\c TCHAR on Windows, when building with Unicode support. Modern\n  Windows releases use UTF-16. Windows releases before 2000 used TCHAR, but\n  only handled UCS-2. UTF-16 _is_ UCS-2, except for the characters that\n  are 4 bytes, which aren't representable in UCS-2 at all anyhow. If you\n  aren't sure, you should be using UTF-16 at this point on Windows.\n\n To ensure that the destination buffer is large enough for the conversion,\n  please allocate a buffer that is double the size of the source buffer.\n  UTF-8 uses from one to four bytes per character, but UTF-16 always uses\n  two to four, so an entirely low-ASCII string will double in size! The\n  UTF-16 characters that would take four bytes also take four bytes in UTF-8,\n  so you don't need to allocate 4x the space just in case: double will do.\n\n Strings that don't fit in the destination buffer will be truncated, but\n  will always be null-terminated and never have an incomplete UTF-16\n  surrogate pair at the end. If the buffer length is 0, this function does\n  nothing.\n\n   \\param src Null-terminated source string in UTF-8 format.\n   \\param dst Buffer to store converted UTF-16 string.\n   \\param len Size, in bytes, of destination buffer.\n\n \\sa PHYSFS_utf8ToUtf16"]
    pub fn PHYSFS_utf8ToUtf16(
        src: *const ::std::os::raw::c_char,
        dst: *mut PHYSFS_uint16,
        len: PHYSFS_uint64,
    );
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_readBytes(PHYSFS_File *handle, void *buffer, PHYSFS_uint64 len)\n \\brief Read bytes from a PhysicsFS filehandle\n\n The file must be opened for reading.\n\n   \\param handle handle returned from PHYSFS_openRead().\n   \\param buffer buffer of at least (len) bytes to store read data into.\n   \\param len number of bytes being read from (handle).\n  \\return number of bytes read. This may be less than (len); this does not\n          signify an error, necessarily (a short read may mean EOF).\n          PHYSFS_getLastErrorCode() can shed light on the reason this might\n          be < (len), as can PHYSFS_eof(). -1 if complete failure.\n\n \\sa PHYSFS_eof"]
    pub fn PHYSFS_readBytes(
        handle: *mut PHYSFS_File,
        buffer: *mut ::std::os::raw::c_void,
        len: PHYSFS_uint64,
    ) -> PHYSFS_sint64;
}
extern "C" {
    #[doc = " \\fn PHYSFS_sint64 PHYSFS_writeBytes(PHYSFS_File *handle, const void *buffer, PHYSFS_uint64 len)\n \\brief Write data to a PhysicsFS filehandle\n\n The file must be opened for writing.\n\n Please note that while (len) is an unsigned 64-bit integer, you are limited\n  to 63 bits (9223372036854775807 bytes), so we can return a negative value\n  on error. If length is greater than 0x7FFFFFFFFFFFFFFF, this function will\n  immediately fail. For systems without a 64-bit datatype, you are limited\n  to 31 bits (0x7FFFFFFF, or 2147483647 bytes). We trust most things won't\n  need to do multiple gigabytes of i/o in one call anyhow, but why limit\n  things?\n\n   \\param handle retval from PHYSFS_openWrite() or PHYSFS_openAppend().\n   \\param buffer buffer of (len) bytes to write to (handle).\n   \\param len number of bytes being written to (handle).\n  \\return number of bytes written. This may be less than (len); in the case\n          of an error, the system may try to write as many bytes as possible,\n          so an incomplete write might occur. PHYSFS_getLastErrorCode() can\n          shed light on the reason this might be < (len). -1 if complete\n          failure."]
    pub fn PHYSFS_writeBytes(
        handle: *mut PHYSFS_File,
        buffer: *const ::std::os::raw::c_void,
        len: PHYSFS_uint64,
    ) -> PHYSFS_sint64;
}
#[doc = " \\struct PHYSFS_Io\n \\brief An abstract i/o interface.\n\n \\warning This is advanced, hardcore stuff. You don't need this unless you\n          really know what you're doing. Most apps will not need this.\n\n Historically, PhysicsFS provided access to the physical filesystem and\n  archives within that filesystem. However, sometimes you need more power\n  than this. Perhaps you need to provide an archive that is entirely\n  contained in RAM, or you need to bridge some other file i/o API to\n  PhysicsFS, or you need to translate the bits (perhaps you have a\n  a standard .zip file that's encrypted, and you need to decrypt on the fly\n  for the unsuspecting zip archiver).\n\n A PHYSFS_Io is the interface that Archivers use to get archive data.\n  Historically, this has mapped to file i/o to the physical filesystem, but\n  as of PhysicsFS 2.1, applications can provide their own i/o implementations\n  at runtime.\n\n This interface isn't necessarily a good universal fit for i/o. There are a\n  few requirements of note:\n\n  - They only do blocking i/o (at least, for now).\n  - They need to be able to duplicate. If you have a file handle from\n    fopen(), you need to be able to create a unique clone of it (so we\n    have two handles to the same file that can both seek/read/etc without\n    stepping on each other).\n  - They need to know the size of their entire data set.\n  - They need to be able to seek and rewind on demand.\n\n ...in short, you're probably not going to write an HTTP implementation.\n\n Thread safety: PHYSFS_Io implementations are not guaranteed to be thread\n  safe in themselves. Under the hood where PhysicsFS uses them, the library\n  provides its own locks. If you plan to use them directly from separate\n  threads, you should either use mutexes to protect them, or don't use the\n  same PHYSFS_Io from two threads at the same time.\n\n \\sa PHYSFS_mountIo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_Io {
    #[doc = " \\brief Binary compatibility information.\n\n This must be set to zero at this time. Future versions of this\n  struct will increment this field, so we know what a given\n  implementation supports. We'll presumably keep supporting older\n  versions as we offer new features, though."]
    pub version: PHYSFS_uint32,
    #[doc = " \\brief Instance data for this struct.\n\n Each instance has a pointer associated with it that can be used to\n  store anything it likes. This pointer is per-instance of the stream,\n  so presumably it will change when calling duplicate(). This can be\n  deallocated during the destroy() method."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Read more data.\n\n Read (len) bytes from the interface, at the current i/o position, and\n  store them in (buffer). The current i/o position should move ahead\n  by the number of bytes successfully read.\n\n You don't have to implement this; set it to NULL if not implemented.\n  This will only be used if the file is opened for reading. If set to\n  NULL, a default implementation that immediately reports failure will\n  be used.\n\n   \\param io The i/o instance to read from.\n   \\param buf The buffer to store data into. It must be at least\n                 (len) bytes long and can't be NULL.\n   \\param len The number of bytes to read from the interface.\n  \\return number of bytes read from file, 0 on EOF, -1 if complete\n          failure."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut PHYSFS_Io,
            buf: *mut ::std::os::raw::c_void,
            len: PHYSFS_uint64,
        ) -> PHYSFS_sint64,
    >,
    #[doc = " \\brief Write more data.\n\n Write (len) bytes from (buffer) to the interface at the current i/o\n  position. The current i/o position should move ahead by the number of\n  bytes successfully written.\n\n You don't have to implement this; set it to NULL if not implemented.\n  This will only be used if the file is opened for writing. If set to\n  NULL, a default implementation that immediately reports failure will\n  be used.\n\n You are allowed to buffer; a write can succeed here and then later\n  fail when flushing. Note that PHYSFS_setBuffer() may be operating a\n  level above your i/o, so you should usually not implement your\n  own buffering routines.\n\n   \\param io The i/o instance to write to.\n   \\param buffer The buffer to read data from. It must be at least\n                 (len) bytes long and can't be NULL.\n   \\param len The number of bytes to read from (buffer).\n  \\return number of bytes written to file, -1 if complete failure."]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut PHYSFS_Io,
            buffer: *const ::std::os::raw::c_void,
            len: PHYSFS_uint64,
        ) -> PHYSFS_sint64,
    >,
    #[doc = " \\brief Move i/o position to a given byte offset from start.\n\n This method moves the i/o position, so the next read/write will\n  be of the byte at (offset) offset. Seeks past the end of file should\n  be treated as an error condition.\n\n   \\param io The i/o instance to seek.\n   \\param offset The new byte offset for the i/o position.\n  \\return non-zero on success, zero on error."]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(io: *mut PHYSFS_Io, offset: PHYSFS_uint64) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\brief Report current i/o position.\n\n Return bytes offset, or -1 if you aren't able to determine. A failure\n  will almost certainly be fatal to further use of this stream, so you\n  may not leave this unimplemented.\n\n   \\param io The i/o instance to query.\n  \\return The current byte offset for the i/o position, -1 if unknown."]
    pub tell: ::std::option::Option<unsafe extern "C" fn(io: *mut PHYSFS_Io) -> PHYSFS_sint64>,
    #[doc = " \\brief Determine size of the i/o instance's dataset.\n\n Return number of bytes available in the file, or -1 if you\n  aren't able to determine. A failure will almost certainly be fatal\n  to further use of this stream, so you may not leave this unimplemented.\n\n   \\param io The i/o instance to query.\n  \\return Total size, in bytes, of the dataset."]
    pub length: ::std::option::Option<unsafe extern "C" fn(io: *mut PHYSFS_Io) -> PHYSFS_sint64>,
    #[doc = " \\brief Duplicate this i/o instance.\n\n This needs to result in a full copy of this PHYSFS_Io, that can live\n  completely independently. The copy needs to be able to perform all\n  its operations without altering the original, including either object\n  being destroyed separately (so, for example: they can't share a file\n  handle; they each need their own).\n\n If you can't duplicate a handle, it's legal to return NULL, but you\n  almost certainly need this functionality if you want to use this to\n  PHYSFS_Io to back an archive.\n\n   \\param io The i/o instance to duplicate.\n  \\return A new value for a stream's (opaque) field, or NULL on error."]
    pub duplicate:
        ::std::option::Option<unsafe extern "C" fn(io: *mut PHYSFS_Io) -> *mut PHYSFS_Io>,
    #[doc = " \\brief Flush resources to media, or wherever.\n\n This is the chance to report failure for writes that had claimed\n  success earlier, but still had a chance to actually fail. This method\n  can be NULL if flushing isn't necessary.\n\n This function may be called before destroy(), as it can report failure\n  and destroy() can not. It may be called at other times, too.\n\n   \\param io The i/o instance to flush.\n  \\return Zero on error, non-zero on success."]
    pub flush:
        ::std::option::Option<unsafe extern "C" fn(io: *mut PHYSFS_Io) -> ::std::os::raw::c_int>,
    #[doc = " \\brief Cleanup and deallocate i/o instance.\n\n Free associated resources, including (opaque) if applicable.\n\n This function must always succeed: as such, it returns void. The\n  system may call your flush() method before this. You may report\n  failure there if necessary. This method may still be called if\n  flush() fails, in which case you'll have to abandon unflushed data\n  and other failing conditions and clean up.\n\n Once this method is called for a given instance, the system will assume\n  it is unsafe to touch that instance again and will discard any\n  references to it.\n\n   \\param s The i/o instance to destroy."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(io: *mut PHYSFS_Io)>,
}
#[test]
fn bindgen_test_layout_PHYSFS_Io() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_Io> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_Io>(),
        80usize,
        concat!("Size of: ", stringify!(PHYSFS_Io))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_Io>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_Io))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duplicate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(duplicate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Io),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    #[doc = " \\fn int PHYSFS_mountIo(PHYSFS_Io *io, const char *newDir, const char *mountPoint, int appendToPath)\n \\brief Add an archive, built on a PHYSFS_Io, to the search path.\n\n \\warning Unless you have some special, low-level need, you should be using\n          PHYSFS_mount() instead of this.\n\n This function operates just like PHYSFS_mount(), but takes a PHYSFS_Io\n  instead of a pathname. Behind the scenes, PHYSFS_mount() calls this\n  function with a physical-filesystem-based PHYSFS_Io.\n\n (newDir) must be a unique string to identify this archive. It is used\n  to optimize archiver selection (if you name it XXXXX.zip, we might try\n  the ZIP archiver first, for example, or directly choose an archiver that\n  can only trust the data is valid by filename extension). It doesn't\n  need to refer to a real file at all. If the filename extension isn't\n  helpful, the system will try every archiver until one works or none\n  of them do. This filename must be unique, as the system won't allow you\n  to have two archives with the same name.\n\n (io) must remain until the archive is unmounted. When the archive is\n  unmounted, the system will call (io)->destroy(io), which will give you\n  a chance to free your resources.\n\n If this function fails, (io)->destroy(io) is not called.\n\n   \\param io i/o instance for archive to add to the path.\n   \\param newDir Filename that can represent this stream.\n   \\param mountPoint Location in the interpolated tree that this archive\n                     will be \"mounted\", in platform-independent notation.\n                     NULL or \"\" is equivalent to \"/\".\n   \\param appendToPath nonzero to append to search path, zero to prepend.\n  \\return nonzero if added to path, zero on failure (bogus archive, stream\n                   i/o issue, etc). Use PHYSFS_getLastErrorCode() to obtain\n                   the specific error.\n\n \\sa PHYSFS_unmount\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_getMountPoint"]
    pub fn PHYSFS_mountIo(
        io: *mut PHYSFS_Io,
        newDir: *const ::std::os::raw::c_char,
        mountPoint: *const ::std::os::raw::c_char,
        appendToPath: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_mountMemory(const void *buf, PHYSFS_uint64 len, void (*del)(void *), const char *newDir, const char *mountPoint, int appendToPath)\n \\brief Add an archive, contained in a memory buffer, to the search path.\n\n \\warning Unless you have some special, low-level need, you should be using\n          PHYSFS_mount() instead of this.\n\n This function operates just like PHYSFS_mount(), but takes a memory buffer\n  instead of a pathname. This buffer contains all the data of the archive,\n  and is used instead of a real file in the physical filesystem.\n\n (newDir) must be a unique string to identify this archive. It is used\n  to optimize archiver selection (if you name it XXXXX.zip, we might try\n  the ZIP archiver first, for example, or directly choose an archiver that\n  can only trust the data is valid by filename extension). It doesn't\n  need to refer to a real file at all. If the filename extension isn't\n  helpful, the system will try every archiver until one works or none\n  of them do. This filename must be unique, as the system won't allow you\n  to have two archives with the same name.\n\n (ptr) must remain until the archive is unmounted. When the archive is\n  unmounted, the system will call (del)(ptr), which will notify you that\n  the system is done with the buffer, and give you a chance to free your\n  resources. (del) can be NULL, in which case the system will make no\n  attempt to free the buffer.\n\n If this function fails, (del) is not called.\n\n   \\param buf Address of the memory buffer containing the archive data.\n   \\param len Size of memory buffer, in bytes.\n   \\param del A callback that triggers upon unmount. Can be NULL.\n   \\param newDir Filename that can represent this stream.\n   \\param mountPoint Location in the interpolated tree that this archive\n                     will be \"mounted\", in platform-independent notation.\n                     NULL or \"\" is equivalent to \"/\".\n   \\param appendToPath nonzero to append to search path, zero to prepend.\n  \\return nonzero if added to path, zero on failure (bogus archive, etc).\n          Use PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_unmount\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_getMountPoint"]
    pub fn PHYSFS_mountMemory(
        buf: *const ::std::os::raw::c_void,
        len: PHYSFS_uint64,
        del: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        newDir: *const ::std::os::raw::c_char,
        mountPoint: *const ::std::os::raw::c_char,
        appendToPath: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_mountHandle(PHYSFS_File *file, const char *newDir, const char *mountPoint, int appendToPath)\n \\brief Add an archive, contained in a PHYSFS_File handle, to the search path.\n\n \\warning Unless you have some special, low-level need, you should be using\n          PHYSFS_mount() instead of this.\n\n \\warning Archives-in-archives may be very slow! While a PHYSFS_File can\n          seek even when the data is compressed, it may do so by rewinding\n          to the start and decompressing everything before the seek point.\n          Normal archive usage may do a lot of seeking behind the scenes.\n          As such, you might find normal archive usage extremely painful\n          if mounted this way. Plan accordingly: if you, say, have a\n          self-extracting .zip file, and want to mount something in it,\n          compress the contents of the inner archive and make sure the outer\n          .zip file doesn't compress the inner archive too.\n\n This function operates just like PHYSFS_mount(), but takes a PHYSFS_File\n  handle instead of a pathname. This handle contains all the data of the\n  archive, and is used instead of a real file in the physical filesystem.\n  The PHYSFS_File may be backed by a real file in the physical filesystem,\n  but isn't necessarily. The most popular use for this is likely to mount\n  archives stored inside other archives.\n\n (newDir) must be a unique string to identify this archive. It is used\n  to optimize archiver selection (if you name it XXXXX.zip, we might try\n  the ZIP archiver first, for example, or directly choose an archiver that\n  can only trust the data is valid by filename extension). It doesn't\n  need to refer to a real file at all. If the filename extension isn't\n  helpful, the system will try every archiver until one works or none\n  of them do. This filename must be unique, as the system won't allow you\n  to have two archives with the same name.\n\n (file) must remain until the archive is unmounted. When the archive is\n  unmounted, the system will call PHYSFS_close(file). If you need this\n  handle to survive, you will have to wrap this in a PHYSFS_Io and use\n  PHYSFS_mountIo() instead.\n\n If this function fails, PHYSFS_close(file) is not called.\n\n   \\param file The PHYSFS_File handle containing archive data.\n   \\param newDir Filename that can represent this stream.\n   \\param mountPoint Location in the interpolated tree that this archive\n                     will be \"mounted\", in platform-independent notation.\n                     NULL or \"\" is equivalent to \"/\".\n   \\param appendToPath nonzero to append to search path, zero to prepend.\n  \\return nonzero if added to path, zero on failure (bogus archive, etc).\n          Use PHYSFS_getLastErrorCode() to obtain the specific error.\n\n \\sa PHYSFS_unmount\n \\sa PHYSFS_getSearchPath\n \\sa PHYSFS_getMountPoint"]
    pub fn PHYSFS_mountHandle(
        file: *mut PHYSFS_File,
        newDir: *const ::std::os::raw::c_char,
        mountPoint: *const ::std::os::raw::c_char,
        appendToPath: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Success; no error."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OK: PHYSFS_ErrorCode = 0;
#[doc = "< Error not otherwise covered here."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OTHER_ERROR: PHYSFS_ErrorCode = 1;
#[doc = "< Memory allocation failed."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OUT_OF_MEMORY: PHYSFS_ErrorCode = 2;
#[doc = "< PhysicsFS is not initialized."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NOT_INITIALIZED: PHYSFS_ErrorCode = 3;
#[doc = "< PhysicsFS is already initialized."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_IS_INITIALIZED: PHYSFS_ErrorCode = 4;
#[doc = "< Needed argv[0], but it is NULL."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_ARGV0_IS_NULL: PHYSFS_ErrorCode = 5;
#[doc = "< Operation or feature unsupported."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_UNSUPPORTED: PHYSFS_ErrorCode = 6;
#[doc = "< Attempted to access past end of file."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_PAST_EOF: PHYSFS_ErrorCode = 7;
#[doc = "< Files still open."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_FILES_STILL_OPEN: PHYSFS_ErrorCode = 8;
#[doc = "< Bad parameter passed to an function."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_INVALID_ARGUMENT: PHYSFS_ErrorCode = 9;
#[doc = "< Requested archive/dir not mounted."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NOT_MOUNTED: PHYSFS_ErrorCode = 10;
#[doc = "< File (or whatever) not found."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NOT_FOUND: PHYSFS_ErrorCode = 11;
#[doc = "< Symlink seen when not permitted."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_SYMLINK_FORBIDDEN: PHYSFS_ErrorCode = 12;
#[doc = "< No write dir has been specified."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NO_WRITE_DIR: PHYSFS_ErrorCode = 13;
#[doc = "< Wrote to a file opened for reading."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OPEN_FOR_READING: PHYSFS_ErrorCode = 14;
#[doc = "< Read from a file opened for writing."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OPEN_FOR_WRITING: PHYSFS_ErrorCode = 15;
#[doc = "< Needed a file, got a directory (etc)."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NOT_A_FILE: PHYSFS_ErrorCode = 16;
#[doc = "< Wrote to a read-only filesystem."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_READ_ONLY: PHYSFS_ErrorCode = 17;
#[doc = "< Corrupted data encountered."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_CORRUPT: PHYSFS_ErrorCode = 18;
#[doc = "< Infinite symbolic link loop."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_SYMLINK_LOOP: PHYSFS_ErrorCode = 19;
#[doc = "< i/o error (hardware failure, etc)."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_IO: PHYSFS_ErrorCode = 20;
#[doc = "< Permission denied."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_PERMISSION: PHYSFS_ErrorCode = 21;
#[doc = "< No space (disk full, over quota, etc)"]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_NO_SPACE: PHYSFS_ErrorCode = 22;
#[doc = "< Filename is bogus/insecure."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_BAD_FILENAME: PHYSFS_ErrorCode = 23;
#[doc = "< Tried to modify a file the OS needs."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_BUSY: PHYSFS_ErrorCode = 24;
#[doc = "< Tried to delete dir with files in it."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_DIR_NOT_EMPTY: PHYSFS_ErrorCode = 25;
#[doc = "< Unspecified OS-level error."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_OS_ERROR: PHYSFS_ErrorCode = 26;
#[doc = "< Duplicate entry."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_DUPLICATE: PHYSFS_ErrorCode = 27;
#[doc = "< Bad password."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_BAD_PASSWORD: PHYSFS_ErrorCode = 28;
#[doc = "< Application callback reported error."]
pub const PHYSFS_ErrorCode_PHYSFS_ERR_APP_CALLBACK: PHYSFS_ErrorCode = 29;
#[doc = " \\enum PHYSFS_ErrorCode\n \\brief Values that represent specific causes of failure.\n\n Most of the time, you should only concern yourself with whether a given\n  operation failed or not, but there may be occasions where you plan to\n  handle a specific failure case gracefully, so we provide specific error\n  codes.\n\n Most of these errors are a little vague, and most aren't things you can\n  fix...if there's a permission error, for example, all you can really do\n  is pass that information on to the user and let them figure out how to\n  handle it. In most these cases, your program should only care that it\n  failed to accomplish its goals, and not care specifically why.\n\n \\sa PHYSFS_getLastErrorCode\n \\sa PHYSFS_getErrorByCode"]
pub type PHYSFS_ErrorCode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\fn PHYSFS_ErrorCode PHYSFS_getLastErrorCode(void)\n \\brief Get machine-readable error information.\n\n Get the last PhysicsFS error message as an integer value. This will return\n  PHYSFS_ERR_OK if there's been no error since the last call to this\n  function. Each thread has a unique error state associated with it, but\n  each time a new error message is set, it will overwrite the previous one\n  associated with that thread. It is safe to call this function at anytime,\n  even before PHYSFS_init().\n\n PHYSFS_getLastError() and PHYSFS_getLastErrorCode() both reset the same\n  thread-specific error state. Calling one will wipe out the other's\n  data. If you need both, call PHYSFS_getLastErrorCode(), then pass that\n  value to PHYSFS_getErrorByCode().\n\n Generally, applications should only concern themselves with whether a\n  given function failed; however, if you require more specifics, you can\n  try this function to glean information, if there's some specific problem\n  you're expecting and plan to handle. But with most things that involve\n  file systems, the best course of action is usually to give up, report the\n  problem to the user, and let them figure out what should be done about it.\n  For that, you might prefer PHYSFS_getErrorByCode() instead.\n\n   \\return Enumeration value that represents last reported error.\n\n \\sa PHYSFS_getErrorByCode"]
    pub fn PHYSFS_getLastErrorCode() -> PHYSFS_ErrorCode;
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getErrorByCode(PHYSFS_ErrorCode code)\n \\brief Get human-readable description string for a given error code.\n\n Get a static string, in UTF-8 format, that represents an English\n  description of a given error code.\n\n This string is guaranteed to never change (although we may add new strings\n  for new error codes in later versions of PhysicsFS), so you can use it\n  for keying a localization dictionary.\n\n It is safe to call this function at anytime, even before PHYSFS_init().\n\n These strings are meant to be passed on directly to the user.\n  Generally, applications should only concern themselves with whether a\n  given function failed, but not care about the specifics much.\n\n Do not attempt to free the returned strings; they are read-only and you\n  don't own their memory pages.\n\n   \\param code Error code to convert to a string.\n   \\return READ ONLY string of requested error message, NULL if this\n           is not a valid PhysicsFS error code. Always check for NULL if\n           you might be looking up an error code that didn't exist in an\n           earlier version of PhysicsFS.\n\n \\sa PHYSFS_getLastErrorCode"]
    pub fn PHYSFS_getErrorByCode(code: PHYSFS_ErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\fn void PHYSFS_setErrorCode(PHYSFS_ErrorCode code)\n \\brief Set the current thread's error code.\n\n This lets you set the value that will be returned by the next call to\n  PHYSFS_getLastErrorCode(). This will replace any existing error code,\n  whether set by your application or internally by PhysicsFS.\n\n Error codes are stored per-thread; what you set here will not be\n  accessible to another thread.\n\n Any call into PhysicsFS may change the current error code, so any code you\n  set here is somewhat fragile, and thus you shouldn't build any serious\n  error reporting framework on this function. The primary goal of this\n  function is to allow PHYSFS_Io implementations to set the error state,\n  which generally will be passed back to your application when PhysicsFS\n  makes a PHYSFS_Io call that fails internally.\n\n This function doesn't care if the error code is a value known to PhysicsFS\n  or not (but PHYSFS_getErrorByCode() will return NULL for unknown values).\n  The value will be reported unmolested by PHYSFS_getLastErrorCode().\n\n   \\param code Error code to become the current thread's new error state.\n\n \\sa PHYSFS_getLastErrorCode\n \\sa PHYSFS_getErrorByCode"]
    pub fn PHYSFS_setErrorCode(code: PHYSFS_ErrorCode);
}
extern "C" {
    #[doc = " \\fn const char *PHYSFS_getPrefDir(const char *org, const char *app)\n \\brief Get the user-and-app-specific path where files can be written.\n\n Helper function.\n\n Get the \"pref dir\". This is meant to be where users can write personal\n  files (preferences and save games, etc) that are specific to your\n  application. This directory is unique per user, per application.\n\n This function will decide the appropriate location in the native filesystem,\n  create the directory if necessary, and return a string in\n  platform-dependent notation, suitable for passing to PHYSFS_setWriteDir().\n\n On Windows, this might look like:\n  \"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\"\n\n On Linux, this might look like:\n  \"/home/bob/.local/share/My Program Name\"\n\n On Mac OS X, this might look like:\n  \"/Users/bob/Library/Application Support/My Program Name\"\n\n (etc.)\n\n You should probably use the pref dir for your write dir, and also put it\n  near the beginning of your search path. Older versions of PhysicsFS\n  offered only PHYSFS_getUserDir() and left you to figure out where the\n  files should go under that tree. This finds the correct location\n  for whatever platform, which not only changes between operating systems,\n  but also versions of the same operating system.\n\n You specify the name of your organization (if it's not a real organization,\n  your name or an Internet domain you own might do) and the name of your\n  application. These should be proper names.\n\n Both the (org) and (app) strings may become part of a directory name, so\n  please follow these rules:\n\n    - Try to use the same org string (including case-sensitivity) for\n      all your applications that use this function.\n    - Always use a unique app string for each one, and make sure it never\n      changes for an app once you've decided on it.\n    - Unicode characters are legal, as long as it's UTF-8 encoded, but...\n    - ...only use letters, numbers, and spaces. Avoid punctuation like\n      \"Game Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient.\n\n The pointer returned by this function remains valid until you call this\n  function again, or call PHYSFS_deinit(). This is not necessarily a fast\n  call, though, so you should call this once at startup and copy the string\n  if you need it.\n\n You should assume the path returned by this function is the only safe\n  place to write files (and that PHYSFS_getUserDir() and PHYSFS_getBaseDir(),\n  while they might be writable, or even parents of the returned path, aren't\n  where you should be writing things).\n\n   \\param org The name of your organization.\n   \\param app The name of your application.\n  \\return READ ONLY string of user dir in platform-dependent notation. NULL\n          if there's a problem (creating directory failed, etc).\n\n \\sa PHYSFS_getBaseDir\n \\sa PHYSFS_getUserDir"]
    pub fn PHYSFS_getPrefDir(
        org: *const ::std::os::raw::c_char,
        app: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " \\struct PHYSFS_Archiver\n \\brief Abstract interface to provide support for user-defined archives.\n\n \\warning This is advanced, hardcore stuff. You don't need this unless you\n          really know what you're doing. Most apps will not need this.\n\n Historically, PhysicsFS provided a means to mount various archive file\n  formats, and physical directories in the native filesystem. However,\n  applications have been limited to the file formats provided by the\n  library. This interface allows an application to provide their own\n  archive file types.\n\n Conceptually, a PHYSFS_Archiver provides directory entries, while\n  PHYSFS_Io provides data streams for those directory entries. The most\n  obvious use of PHYSFS_Archiver is to provide support for an archive\n  file type that isn't provided by PhysicsFS directly: perhaps some\n  proprietary format that only your application needs to understand.\n\n Internally, all the built-in archive support uses this interface, so the\n  best examples for building a PHYSFS_Archiver is the source code to\n  PhysicsFS itself.\n\n An archiver is added to the system with PHYSFS_registerArchiver(), and then\n  it will be available for use automatically with PHYSFS_mount(); if a\n  given archive can be handled with your archiver, it will be given control\n  as appropriate.\n\n These methods deal with dir handles. You have one instance of your\n  archiver, and it generates a unique, opaque handle for each opened\n  archive in its openArchive() method. Since the lifetime of an Archiver\n  (not an archive) is generally the entire lifetime of the process, and it's\n  assumed to be a singleton, we do not provide any instance data for the\n  archiver itself; the app can just use some static variables if necessary.\n\n Symlinks should always be followed (except in stat()); PhysicsFS will\n  use the stat() method to check for symlinks and make a judgement on\n  whether to continue to call other methods based on that.\n\n Archivers, when necessary, should set the PhysicsFS error state with\n  PHYSFS_setErrorCode() before returning. PhysicsFS will pass these errors\n  back to the application unmolested in most cases.\n\n Thread safety: PHYSFS_Archiver implementations are not guaranteed to be\n  thread safe in themselves. PhysicsFS provides thread safety when it calls\n  into a given archiver inside the library, but it does not promise that\n  using the same PHYSFS_File from two threads at once is thread-safe; as\n  such, your PHYSFS_Archiver can assume that locking is handled for you\n  so long as the PHYSFS_Io you return from PHYSFS_open* doesn't change any\n  of your Archiver state, as the PHYSFS_Io won't be as aggressively\n  protected.\n\n \\sa PHYSFS_registerArchiver\n \\sa PHYSFS_deregisterArchiver\n \\sa PHYSFS_supportedArchiveTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PHYSFS_Archiver {
    #[doc = " \\brief Binary compatibility information.\n\n This must be set to zero at this time. Future versions of this\n  struct will increment this field, so we know what a given\n  implementation supports. We'll presumably keep supporting older\n  versions as we offer new features, though."]
    pub version: PHYSFS_uint32,
    #[doc = " \\brief Basic info about this archiver.\n\n This is used to identify your archive, and is returned in\n  PHYSFS_supportedArchiveTypes()."]
    pub info: PHYSFS_ArchiveInfo,
    #[doc = " \\brief Open an archive provided by (io).\n\n This is where resources are allocated and data is parsed when mounting\n  an archive.\n (name) is a filename associated with (io), but doesn't necessarily\n  map to anything, let alone a real filename. This possibly-\n  meaningless name is in platform-dependent notation.\n (forWrite) is non-zero if this is to be used for\n  the write directory, and zero if this is to be used for an\n  element of the search path.\n (claimed) should be set to 1 if this is definitely an archive your\n  archiver implementation can handle, even if it fails. We use to\n  decide if we should stop trying other archivers if you fail to open\n  it. For example: the .zip archiver will set this to 1 for something\n  that's got a .zip file signature, even if it failed because the file\n  was also truncated. No sense in trying other archivers here, we\n  already tried to handle it with the appropriate implementation!.\n Return NULL on failure and set (claimed) appropriately. If no archiver\n  opened the archive or set (claimed), PHYSFS_mount() will report\n  PHYSFS_ERR_UNSUPPORTED. Otherwise, it will report the error from the\n  archiver that claimed the data through (claimed).\n Return non-NULL on success. The pointer returned will be\n  passed as the \"opaque\" parameter for later calls."]
    pub openArchive: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut PHYSFS_Io,
            name: *const ::std::os::raw::c_char,
            forWrite: ::std::os::raw::c_int,
            claimed: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " \\brief List all files in (dirname).\n\n Each file is passed to (cb), where a copy is made if appropriate, so\n  you can dispose of it upon return from the callback. (dirname) is in\n  platform-independent notation.\n If you have a failure, call PHYSFS_SetErrorCode() with whatever code\n  seem appropriate and return PHYSFS_ENUM_ERROR.\n If the callback returns PHYSFS_ENUM_ERROR, please call\n  PHYSFS_SetErrorCode(PHYSFS_ERR_APP_CALLBACK) and then return\n  PHYSFS_ENUM_ERROR as well. Don't call the callback again in any\n  circumstances.\n If the callback returns PHYSFS_ENUM_STOP, stop enumerating and return\n  PHYSFS_ENUM_STOP as well. Don't call the callback again in any\n  circumstances. Don't set an error code in this case.\n Callbacks are only supposed to return a value from\n  PHYSFS_EnumerateCallbackResult. Any other result has undefined\n  behavior.\n As long as the callback returned PHYSFS_ENUM_OK and you haven't\n  experienced any errors of your own, keep enumerating until you're done\n  and then return PHYSFS_ENUM_OK without setting an error code.\n\n \\warning PHYSFS_enumerate returns zero or non-zero (success or failure),\n          so be aware this function pointer returns different values!"]
    pub enumerate: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            dirname: *const ::std::os::raw::c_char,
            cb: PHYSFS_EnumerateCallback,
            origdir: *const ::std::os::raw::c_char,
            callbackdata: *mut ::std::os::raw::c_void,
        ) -> PHYSFS_EnumerateCallbackResult,
    >,
    #[doc = " \\brief Open a file in this archive for reading.\n\n This filename, (fnm), is in platform-independent notation.\n Fail if the file does not exist.\n Returns NULL on failure, and calls PHYSFS_setErrorCode().\n  Returns non-NULL on success. The pointer returned will be\n  passed as the \"opaque\" parameter for later file calls."]
    pub openRead: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            fnm: *const ::std::os::raw::c_char,
        ) -> *mut PHYSFS_Io,
    >,
    #[doc = " \\brief Open a file in this archive for writing.\n\n If the file does not exist, it should be created. If it exists,\n  it should be truncated to zero bytes. The writing offset should\n  be the start of the file.\n If the archive is read-only, this operation should fail.\n This filename is in platform-independent notation.\n Returns NULL on failure, and calls PHYSFS_setErrorCode().\n  Returns non-NULL on success. The pointer returned will be\n  passed as the \"opaque\" parameter for later file calls."]
    pub openWrite: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            filename: *const ::std::os::raw::c_char,
        ) -> *mut PHYSFS_Io,
    >,
    #[doc = " \\brief Open a file in this archive for appending.\n\n If the file does not exist, it should be created. The writing\n  offset should be the end of the file.\n If the archive is read-only, this operation should fail.\n This filename is in platform-independent notation.\n Returns NULL on failure, and calls PHYSFS_setErrorCode().\n  Returns non-NULL on success. The pointer returned will be\n  passed as the \"opaque\" parameter for later file calls."]
    pub openAppend: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            filename: *const ::std::os::raw::c_char,
        ) -> *mut PHYSFS_Io,
    >,
    #[doc = " \\brief Delete a file or directory in the archive.\n\n This same call is used for both files and directories; there is not a\n  separate rmdir() call. Directories are only meant to be removed if\n  they are empty.\n If the archive is read-only, this operation should fail.\n\n Return non-zero on success, zero on failure.\n This filename is in platform-independent notation.\n On failure, call PHYSFS_setErrorCode()."]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            filename: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\brief Create a directory in the archive.\n\n If the application is trying to make multiple dirs, PhysicsFS\n  will split them up into multiple calls before passing them to\n  your driver.\n If the archive is read-only, this operation should fail.\n Return non-zero on success, zero on failure.\n  This filename is in platform-independent notation.\n On failure, call PHYSFS_setErrorCode()."]
    pub mkdir: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            filename: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\brief Obtain basic file metadata.\n\n On success, fill in all the fields in (stat), using\n  reasonable defaults for fields that apply to your archive.\n\n Returns non-zero on success, zero on failure.\n This filename is in platform-independent notation.\n On failure, call PHYSFS_setErrorCode()."]
    pub stat: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            fn_: *const ::std::os::raw::c_char,
            stat: *mut PHYSFS_Stat,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\brief Destruct a previously-opened archive.\n\n Close this archive, and free any associated memory,\n  including the original PHYSFS_Io and (opaque) itself, if\n  applicable. Implementation can assume that it won't be called if\n  there are still files open from this archive."]
    pub closeArchive:
        ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_PHYSFS_Archiver() {
    const UNINIT: ::std::mem::MaybeUninit<PHYSFS_Archiver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PHYSFS_Archiver>(),
        120usize,
        concat!("Size of: ", stringify!(PHYSFS_Archiver))
    );
    assert_eq!(
        ::std::mem::align_of::<PHYSFS_Archiver>(),
        8usize,
        concat!("Alignment of ", stringify!(PHYSFS_Archiver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openArchive) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(openArchive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openRead) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(openRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openWrite) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(openWrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openAppend) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(openAppend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closeArchive) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PHYSFS_Archiver),
            "::",
            stringify!(closeArchive)
        )
    );
}
extern "C" {
    #[doc = " \\fn int PHYSFS_registerArchiver(const PHYSFS_Archiver *archiver)\n \\brief Add a new archiver to the system.\n\n \\warning This is advanced, hardcore stuff. You don't need this unless you\n          really know what you're doing. Most apps will not need this.\n\n If you want to provide your own archiver (for example, a custom archive\n  file format, or some virtual thing you want to make look like a filesystem\n  that you can access through the usual PhysicsFS APIs), this is where you\n  start. Once an archiver is successfully registered, then you can use\n  PHYSFS_mount() to add archives that your archiver supports to the\n  search path, or perhaps use it as the write dir. Internally, PhysicsFS\n  uses this function to register its own built-in archivers, like .zip\n  support, etc.\n\n You may not have two archivers that handle the same extension. If you are\n  going to have a clash, you can deregister the other archiver (including\n  built-in ones) with PHYSFS_deregisterArchiver().\n\n The data in (archiver) is copied; you may free this pointer when this\n  function returns.\n\n Once this function returns successfully, PhysicsFS will be able to support\n  archives of this type until you deregister the archiver again.\n\n   \\param archiver The archiver to register.\n  \\return Zero on error, non-zero on success.\n\n \\sa PHYSFS_Archiver\n \\sa PHYSFS_deregisterArchiver"]
    pub fn PHYSFS_registerArchiver(archiver: *const PHYSFS_Archiver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int PHYSFS_deregisterArchiver(const char *ext)\n \\brief Remove an archiver from the system.\n\n If for some reason, you only need your previously-registered archiver to\n  live for a portion of your app's lifetime, you can remove it from the\n  system once you're done with it through this function.\n\n This fails if there are any archives still open that use this archiver.\n\n This function can also remove internally-supplied archivers, like .zip\n  support or whatnot. This could be useful in some situations, like\n  disabling support for them outright or overriding them with your own\n  implementation. Once an internal archiver is disabled like this,\n  PhysicsFS provides no mechanism to recover them, short of calling\n  PHYSFS_deinit() and PHYSFS_init() again.\n\n PHYSFS_deinit() will automatically deregister all archivers, so you don't\n  need to explicitly deregister yours if you otherwise shut down cleanly.\n\n   \\param ext Filename extension that the archiver handles.\n  \\return Zero on error, non-zero on success.\n\n \\sa PHYSFS_Archiver\n \\sa PHYSFS_registerArchiver"]
    pub fn PHYSFS_deregisterArchiver(ext: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
